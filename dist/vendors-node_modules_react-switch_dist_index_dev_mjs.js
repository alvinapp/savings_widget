"use strict";
(self["webpackChunksavings_widget"] = self["webpackChunksavings_widget"] || []).push([["vendors-node_modules_react-switch_dist_index_dev_mjs"],{

/***/ "./node_modules/react-switch/dist/index.dev.mjs":
/*!******************************************************!*\
  !*** ./node_modules/react-switch/dist/index.dev.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ReactSwitch)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");



function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends.apply(this, arguments);
}

/*
The MIT License (MIT)

Copyright (c) 2015 instructure-react

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/
var uncheckedIcon = react__WEBPACK_IMPORTED_MODULE_0__.createElement('svg', {
  viewBox: "-2 -5 14 20",
  height: "100%",
  width: "100%",
  style: {
    position: "absolute",
    top: 0
  }
}, react__WEBPACK_IMPORTED_MODULE_0__.createElement('path', {
  d: "M9.9 2.12L7.78 0 4.95 2.828 2.12 0 0 2.12l2.83 2.83L0 7.776 2.123 9.9 4.95 7.07 7.78 9.9 9.9 7.776 7.072 4.95 9.9 2.12",
  fill: "#fff",
  fillRule: "evenodd"
}));
var checkedIcon = react__WEBPACK_IMPORTED_MODULE_0__.createElement('svg', {
  height: "100%",
  width: "100%",
  viewBox: "-2 -5 17 21",
  style: {
    position: "absolute",
    top: 0
  }
}, react__WEBPACK_IMPORTED_MODULE_0__.createElement('path', {
  d: "M11.264 0L5.26 6.004 2.103 2.847 0 4.95l5.26 5.26 8.108-8.107L11.264 0",
  fill: "#fff",
  fillRule: "evenodd"
}));

function createBackgroundColor(pos, checkedPos, uncheckedPos, offColor, onColor) {
  var relativePos = (pos - uncheckedPos) / (checkedPos - uncheckedPos);

  if (relativePos === 0) {
    return offColor;
  }

  if (relativePos === 1) {
    return onColor;
  }

  var newColor = "#";

  for (var i = 1; i < 6; i += 2) {
    var offComponent = parseInt(offColor.substr(i, 2), 16);
    var onComponent = parseInt(onColor.substr(i, 2), 16);
    var weightedValue = Math.round((1 - relativePos) * offComponent + relativePos * onComponent);
    var newComponent = weightedValue.toString(16);

    if (newComponent.length === 1) {
      newComponent = "0" + newComponent;
    }

    newColor += newComponent;
  }

  return newColor;
}

function convertShorthandColor(color) {
  if (color.length === 7) {
    return color;
  }

  var sixDigitColor = "#";

  for (var i = 1; i < 4; i += 1) {
    sixDigitColor += color[i] + color[i];
  }

  return sixDigitColor;
}

function getBackgroundColor(pos, checkedPos, uncheckedPos, offColor, onColor) {
  var sixDigitOffColor = convertShorthandColor(offColor);
  var sixDigitOnColor = convertShorthandColor(onColor);
  return createBackgroundColor(pos, checkedPos, uncheckedPos, sixDigitOffColor, sixDigitOnColor);
}

// Make sure color props are strings that start with "#" since other ways to write colors are not supported.
var hexColorPropType = function (props, propName, componentName) {
  var prop = props[propName];

  if (typeof prop !== "string" || prop[0] !== "#" || prop.length !== 4 && prop.length !== 7) {
    return new Error("Invalid prop '" + propName + "' supplied to '" + componentName + "'. '" + propName + "' has to be either a 3-digit or 6-digit hex-color string. Valid examples: '#abc', '#123456'");
  }

  return null;
};

function objectWithoutProperties(obj, exclude) {
  var target = {};

  for (var k in obj) if (Object.prototype.hasOwnProperty.call(obj, k) && exclude.indexOf(k) === -1) target[k] = obj[k];

  return target;
}

var ReactSwitch = /*@__PURE__*/function (Component) {
  function ReactSwitch(props) {
    Component.call(this, props);
    var height = props.height;
    var width = props.width;
    var handleDiameter = props.handleDiameter;
    var checked = props.checked;
    this.$handleDiameter = handleDiameter || height - 2;
    this.$checkedPos = Math.max(width - height, width - (height + this.$handleDiameter) / 2);
    this.$uncheckedPos = Math.max(0, (height - this.$handleDiameter) / 2);
    this.state = {
      $pos: checked ? this.$checkedPos : this.$uncheckedPos
    };
    this.$lastDragAt = 0;
    this.$lastKeyUpAt = 0;
    this.$onMouseDown = this.$onMouseDown.bind(this);
    this.$onMouseMove = this.$onMouseMove.bind(this);
    this.$onMouseUp = this.$onMouseUp.bind(this);
    this.$onTouchStart = this.$onTouchStart.bind(this);
    this.$onTouchMove = this.$onTouchMove.bind(this);
    this.$onTouchEnd = this.$onTouchEnd.bind(this);
    this.$onClick = this.$onClick.bind(this);
    this.$onInputChange = this.$onInputChange.bind(this);
    this.$onKeyUp = this.$onKeyUp.bind(this);
    this.$setHasOutline = this.$setHasOutline.bind(this);
    this.$unsetHasOutline = this.$unsetHasOutline.bind(this);
    this.$getInputRef = this.$getInputRef.bind(this);
  }

  if (Component) ReactSwitch.__proto__ = Component;
  ReactSwitch.prototype = Object.create(Component && Component.prototype);
  ReactSwitch.prototype.constructor = ReactSwitch;

  ReactSwitch.prototype.componentDidMount = function componentDidMount() {
    this.$isMounted = true;
  };

  ReactSwitch.prototype.componentDidUpdate = function componentDidUpdate(prevProps) {
    if (prevProps.checked === this.props.checked) {
      return;
    }

    var $pos = this.props.checked ? this.$checkedPos : this.$uncheckedPos;
    this.setState({
      $pos: $pos
    });
  };

  ReactSwitch.prototype.componentWillUnmount = function componentWillUnmount() {
    this.$isMounted = false;
  };

  ReactSwitch.prototype.$onDragStart = function $onDragStart(clientX) {
    this.$inputRef.focus();
    this.setState({
      $startX: clientX,
      $hasOutline: true,
      $dragStartingTime: Date.now()
    });
  };

  ReactSwitch.prototype.$onDrag = function $onDrag(clientX) {
    var ref = this.state;
    var $startX = ref.$startX;
    var $isDragging = ref.$isDragging;
    var $pos = ref.$pos;
    var ref$1 = this.props;
    var checked = ref$1.checked;
    var startPos = checked ? this.$checkedPos : this.$uncheckedPos;
    var mousePos = startPos + clientX - $startX; // We need this check to fix a windows glitch where onDrag is triggered onMouseDown in some cases

    if (!$isDragging && clientX !== $startX) {
      this.setState({
        $isDragging: true
      });
    }

    var newPos = Math.min(this.$checkedPos, Math.max(this.$uncheckedPos, mousePos)); // Prevent unnecessary rerenders

    if (newPos !== $pos) {
      this.setState({
        $pos: newPos
      });
    }
  };

  ReactSwitch.prototype.$onDragStop = function $onDragStop(event) {
    var ref = this.state;
    var $pos = ref.$pos;
    var $isDragging = ref.$isDragging;
    var $dragStartingTime = ref.$dragStartingTime;
    var ref$1 = this.props;
    var checked = ref$1.checked;
    var halfwayCheckpoint = (this.$checkedPos + this.$uncheckedPos) / 2;
    /*
      Set position state back to the previous position even if user drags the switch with intention to change the state.
      This is to prevent the switch from getting stuck in the middle if the event isn't handled in the onChange callback.
    */

    var prevPos = this.props.checked ? this.$checkedPos : this.$uncheckedPos;
    this.setState({
      $pos: prevPos
    }); // Act as if the user clicked the handle if they didn't drag it _or_ the dragged it for less than 250ms

    var timeSinceStart = Date.now() - $dragStartingTime;
    var isSimulatedClick = !$isDragging || timeSinceStart < 250; // Handle when the user has dragged the switch more than halfway from either side

    var isDraggedHalfway = checked && $pos <= halfwayCheckpoint || !checked && $pos >= halfwayCheckpoint;

    if (isSimulatedClick || isDraggedHalfway) {
      this.$onChange(event);
    }

    if (this.$isMounted) {
      this.setState({
        $isDragging: false,
        $hasOutline: false
      });
    }

    this.$lastDragAt = Date.now();
  };

  ReactSwitch.prototype.$onMouseDown = function $onMouseDown(event) {
    event.preventDefault(); // Ignore right click and scroll

    if (typeof event.button === "number" && event.button !== 0) {
      return;
    }

    this.$onDragStart(event.clientX);
    window.addEventListener("mousemove", this.$onMouseMove);
    window.addEventListener("mouseup", this.$onMouseUp);
  };

  ReactSwitch.prototype.$onMouseMove = function $onMouseMove(event) {
    event.preventDefault();
    this.$onDrag(event.clientX);
  };

  ReactSwitch.prototype.$onMouseUp = function $onMouseUp(event) {
    this.$onDragStop(event);
    window.removeEventListener("mousemove", this.$onMouseMove);
    window.removeEventListener("mouseup", this.$onMouseUp);
  };

  ReactSwitch.prototype.$onTouchStart = function $onTouchStart(event) {
    this.$checkedStateFromDragging = null;
    this.$onDragStart(event.touches[0].clientX);
  };

  ReactSwitch.prototype.$onTouchMove = function $onTouchMove(event) {
    this.$onDrag(event.touches[0].clientX);
  };

  ReactSwitch.prototype.$onTouchEnd = function $onTouchEnd(event) {
    event.preventDefault();
    this.$onDragStop(event);
  };

  ReactSwitch.prototype.$onInputChange = function $onInputChange(event) {
    // This condition is unfortunately needed in some browsers where the input's change event might get triggered
    // right after the dragstop event is triggered (occurs when dropping over a label element)
    if (Date.now() - this.$lastDragAt > 50) {
      this.$onChange(event); // Prevent clicking label, but not key activation from setting outline to true - yes, this is absurd

      if (Date.now() - this.$lastKeyUpAt > 50) {
        if (this.$isMounted) {
          this.setState({
            $hasOutline: false
          });
        }
      }
    }
  };

  ReactSwitch.prototype.$onKeyUp = function $onKeyUp() {
    this.$lastKeyUpAt = Date.now();
  };

  ReactSwitch.prototype.$setHasOutline = function $setHasOutline() {
    this.setState({
      $hasOutline: true
    });
  };

  ReactSwitch.prototype.$unsetHasOutline = function $unsetHasOutline() {
    this.setState({
      $hasOutline: false
    });
  };

  ReactSwitch.prototype.$getInputRef = function $getInputRef(el) {
    this.$inputRef = el;
  };

  ReactSwitch.prototype.$onClick = function $onClick(event) {
    event.preventDefault();
    this.$inputRef.focus();
    this.$onChange(event);

    if (this.$isMounted) {
      this.setState({
        $hasOutline: false
      });
    }
  };

  ReactSwitch.prototype.$onChange = function $onChange(event) {
    var ref = this.props;
    var checked = ref.checked;
    var onChange = ref.onChange;
    var id = ref.id;
    onChange(!checked, event, id);
  };

  ReactSwitch.prototype.render = function render() {
    var ref = this.props;
    var checked = ref.checked;
    var disabled = ref.disabled;
    var className = ref.className;
    var offColor = ref.offColor;
    var onColor = ref.onColor;
    var offHandleColor = ref.offHandleColor;
    var onHandleColor = ref.onHandleColor;
    var checkedIcon = ref.checkedIcon;
    var uncheckedIcon = ref.uncheckedIcon;
    var checkedHandleIcon = ref.checkedHandleIcon;
    var uncheckedHandleIcon = ref.uncheckedHandleIcon;
    var boxShadow = ref.boxShadow;
    var activeBoxShadow = ref.activeBoxShadow;
    var height = ref.height;
    var width = ref.width;
    var borderRadius = ref.borderRadius;
    ref.handleDiameter;
    var rest$1 = objectWithoutProperties(ref, ["checked", "disabled", "className", "offColor", "onColor", "offHandleColor", "onHandleColor", "checkedIcon", "uncheckedIcon", "checkedHandleIcon", "uncheckedHandleIcon", "boxShadow", "activeBoxShadow", "height", "width", "borderRadius", "handleDiameter"]);
    var rest = rest$1;
    var ref$1 = this.state;
    var $pos = ref$1.$pos;
    var $isDragging = ref$1.$isDragging;
    var $hasOutline = ref$1.$hasOutline;
    var rootStyle = {
      position: "relative",
      display: "inline-block",
      textAlign: "left",
      opacity: disabled ? 0.5 : 1,
      direction: "ltr",
      borderRadius: height / 2,
      WebkitTransition: "opacity 0.25s",
      MozTransition: "opacity 0.25s",
      transition: "opacity 0.25s",
      touchAction: "none",
      WebkitTapHighlightColor: "rgba(0, 0, 0, 0)",
      WebkitUserSelect: "none",
      MozUserSelect: "none",
      msUserSelect: "none",
      userSelect: "none"
    };
    var backgroundStyle = {
      height: height,
      width: width,
      margin: Math.max(0, (this.$handleDiameter - height) / 2),
      position: "relative",
      background: getBackgroundColor($pos, this.$checkedPos, this.$uncheckedPos, offColor, onColor),
      borderRadius: typeof borderRadius === "number" ? borderRadius : height / 2,
      cursor: disabled ? "default" : "pointer",
      WebkitTransition: $isDragging ? null : "background 0.25s",
      MozTransition: $isDragging ? null : "background 0.25s",
      transition: $isDragging ? null : "background 0.25s"
    };
    var checkedIconStyle = {
      height: height,
      width: Math.min(height * 1.5, width - (this.$handleDiameter + height) / 2 + 1),
      position: "relative",
      opacity: ($pos - this.$uncheckedPos) / (this.$checkedPos - this.$uncheckedPos),
      pointerEvents: "none",
      WebkitTransition: $isDragging ? null : "opacity 0.25s",
      MozTransition: $isDragging ? null : "opacity 0.25s",
      transition: $isDragging ? null : "opacity 0.25s"
    };
    var uncheckedIconStyle = {
      height: height,
      width: Math.min(height * 1.5, width - (this.$handleDiameter + height) / 2 + 1),
      position: "absolute",
      opacity: 1 - ($pos - this.$uncheckedPos) / (this.$checkedPos - this.$uncheckedPos),
      right: 0,
      top: 0,
      pointerEvents: "none",
      WebkitTransition: $isDragging ? null : "opacity 0.25s",
      MozTransition: $isDragging ? null : "opacity 0.25s",
      transition: $isDragging ? null : "opacity 0.25s"
    };
    var handleStyle = {
      height: this.$handleDiameter,
      width: this.$handleDiameter,
      background: getBackgroundColor($pos, this.$checkedPos, this.$uncheckedPos, offHandleColor, onHandleColor),
      display: "inline-block",
      cursor: disabled ? "default" : "pointer",
      borderRadius: typeof borderRadius === "number" ? borderRadius - 1 : "50%",
      position: "absolute",
      transform: "translateX(" + $pos + "px)",
      top: Math.max(0, (height - this.$handleDiameter) / 2),
      outline: 0,
      boxShadow: $hasOutline ? activeBoxShadow : boxShadow,
      border: 0,
      WebkitTransition: $isDragging ? null : "background-color 0.25s, transform 0.25s, box-shadow 0.15s",
      MozTransition: $isDragging ? null : "background-color 0.25s, transform 0.25s, box-shadow 0.15s",
      transition: $isDragging ? null : "background-color 0.25s, transform 0.25s, box-shadow 0.15s"
    };
    var uncheckedHandleIconStyle = {
      height: this.$handleDiameter,
      width: this.$handleDiameter,
      opacity: Math.max((1 - ($pos - this.$uncheckedPos) / (this.$checkedPos - this.$uncheckedPos) - 0.5) * 2, 0),
      position: "absolute",
      left: 0,
      top: 0,
      pointerEvents: "none",
      WebkitTransition: $isDragging ? null : "opacity 0.25s",
      MozTransition: $isDragging ? null : "opacity 0.25s",
      transition: $isDragging ? null : "opacity 0.25s"
    };
    var checkedHandleIconStyle = {
      height: this.$handleDiameter,
      width: this.$handleDiameter,
      opacity: Math.max((($pos - this.$uncheckedPos) / (this.$checkedPos - this.$uncheckedPos) - 0.5) * 2, 0),
      position: "absolute",
      left: 0,
      top: 0,
      pointerEvents: "none",
      WebkitTransition: $isDragging ? null : "opacity 0.25s",
      MozTransition: $isDragging ? null : "opacity 0.25s",
      transition: $isDragging ? null : "opacity 0.25s"
    };
    var inputStyle = {
      border: 0,
      clip: "rect(0 0 0 0)",
      height: 1,
      margin: -1,
      overflow: "hidden",
      padding: 0,
      position: "absolute",
      width: 1
    };
    return react__WEBPACK_IMPORTED_MODULE_0__.createElement('div', {
      className: className,
      style: rootStyle
    }, react__WEBPACK_IMPORTED_MODULE_0__.createElement('div', {
      className: "react-switch-bg",
      style: backgroundStyle,
      onClick: disabled ? null : this.$onClick,
      onMouseDown: function (e) {
        return e.preventDefault();
      }
    }, checkedIcon && react__WEBPACK_IMPORTED_MODULE_0__.createElement('div', {
      style: checkedIconStyle
    }, checkedIcon), uncheckedIcon && react__WEBPACK_IMPORTED_MODULE_0__.createElement('div', {
      style: uncheckedIconStyle
    }, uncheckedIcon)), react__WEBPACK_IMPORTED_MODULE_0__.createElement('div', {
      className: "react-switch-handle",
      style: handleStyle,
      onClick: function (e) {
        return e.preventDefault();
      },
      onMouseDown: disabled ? null : this.$onMouseDown,
      onTouchStart: disabled ? null : this.$onTouchStart,
      onTouchMove: disabled ? null : this.$onTouchMove,
      onTouchEnd: disabled ? null : this.$onTouchEnd,
      onTouchCancel: disabled ? null : this.$unsetHasOutline
    }, uncheckedHandleIcon && react__WEBPACK_IMPORTED_MODULE_0__.createElement('div', {
      style: uncheckedHandleIconStyle
    }, uncheckedHandleIcon), checkedHandleIcon && react__WEBPACK_IMPORTED_MODULE_0__.createElement('div', {
      style: checkedHandleIconStyle
    }, checkedHandleIcon)), react__WEBPACK_IMPORTED_MODULE_0__.createElement('input', _extends({}, {
      type: "checkbox",
      role: "switch",
      'aria-checked': checked,
      checked: checked,
      disabled: disabled,
      style: inputStyle
    }, rest, {
      ref: this.$getInputRef,
      onFocus: this.$setHasOutline,
      onBlur: this.$unsetHasOutline,
      onKeyUp: this.$onKeyUp,
      onChange: this.$onInputChange
    })));
  };

  return ReactSwitch;
}(react__WEBPACK_IMPORTED_MODULE_0__.Component);

ReactSwitch.propTypes = {
  checked: prop_types__WEBPACK_IMPORTED_MODULE_1__.bool.isRequired,
  onChange: prop_types__WEBPACK_IMPORTED_MODULE_1__.func.isRequired,
  disabled: prop_types__WEBPACK_IMPORTED_MODULE_1__.bool,
  offColor: hexColorPropType,
  onColor: hexColorPropType,
  offHandleColor: hexColorPropType,
  onHandleColor: hexColorPropType,
  handleDiameter: prop_types__WEBPACK_IMPORTED_MODULE_1__.number,
  uncheckedIcon: prop_types__WEBPACK_IMPORTED_MODULE_1__.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_1__.bool, prop_types__WEBPACK_IMPORTED_MODULE_1__.element]),
  checkedIcon: prop_types__WEBPACK_IMPORTED_MODULE_1__.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_1__.bool, prop_types__WEBPACK_IMPORTED_MODULE_1__.element]),
  boxShadow: prop_types__WEBPACK_IMPORTED_MODULE_1__.string,
  borderRadius: prop_types__WEBPACK_IMPORTED_MODULE_1__.number,
  activeBoxShadow: prop_types__WEBPACK_IMPORTED_MODULE_1__.string,
  uncheckedHandleIcon: prop_types__WEBPACK_IMPORTED_MODULE_1__.element,
  checkedHandleIcon: prop_types__WEBPACK_IMPORTED_MODULE_1__.element,
  height: prop_types__WEBPACK_IMPORTED_MODULE_1__.number,
  width: prop_types__WEBPACK_IMPORTED_MODULE_1__.number,
  id: prop_types__WEBPACK_IMPORTED_MODULE_1__.string,
  className: prop_types__WEBPACK_IMPORTED_MODULE_1__.string
};
ReactSwitch.defaultProps = {
  disabled: false,
  offColor: "#888",
  onColor: "#080",
  offHandleColor: "#fff",
  onHandleColor: "#fff",
  uncheckedIcon: uncheckedIcon,
  checkedIcon: checkedIcon,
  boxShadow: null,
  activeBoxShadow: "0 0 2px 3px #3bf",
  height: 28,
  width: 56
};




/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfcmVhY3Qtc3dpdGNoX2Rpc3RfaW5kZXhfZGV2X21qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBeUM7QUFDTjs7QUFFbkM7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnREFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUUsZ0RBQW1CO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxrQkFBa0IsZ0RBQW1CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFFLGdEQUFtQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEOztBQUVqRDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUEscUZBQXFGOztBQUVyRjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSyxHQUFHOztBQUVSO0FBQ0EsaUVBQWlFOztBQUVqRTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDRCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdEQUFtQjtBQUM5QjtBQUNBO0FBQ0EsS0FBSyxFQUFFLGdEQUFtQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLGlCQUFpQixnREFBbUI7QUFDekM7QUFDQSxLQUFLLGlDQUFpQyxnREFBbUI7QUFDekQ7QUFDQSxLQUFLLG1CQUFtQixnREFBbUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUsseUJBQXlCLGdEQUFtQjtBQUNqRDtBQUNBLEtBQUssNkNBQTZDLGdEQUFtQjtBQUNyRTtBQUNBLEtBQUssdUJBQXVCLGdEQUFtQixxQkFBcUI7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxDQUFDLENBQUMsNENBQVM7O0FBRVg7QUFDQSxXQUFXLHVEQUF5QjtBQUNwQyxZQUFZLHVEQUF5QjtBQUNyQyxZQUFZLDRDQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDhDQUFnQjtBQUNsQyxpQkFBaUIsaURBQW1CLEVBQUUsNENBQWMsRUFBRSwrQ0FBaUI7QUFDdkUsZUFBZSxpREFBbUIsRUFBRSw0Q0FBYyxFQUFFLCtDQUFpQjtBQUNyRSxhQUFhLDhDQUFnQjtBQUM3QixnQkFBZ0IsOENBQWdCO0FBQ2hDLG1CQUFtQiw4Q0FBZ0I7QUFDbkMsdUJBQXVCLCtDQUFpQjtBQUN4QyxxQkFBcUIsK0NBQWlCO0FBQ3RDLFVBQVUsOENBQWdCO0FBQzFCLFNBQVMsOENBQWdCO0FBQ3pCLE1BQU0sOENBQWdCO0FBQ3RCLGFBQWEsOENBQWdCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2F2aW5ncy13aWRnZXQvLi9ub2RlX21vZHVsZXMvcmVhY3Qtc3dpdGNoL2Rpc3QvaW5kZXguZGV2Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcblxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG4vKlxuVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbkNvcHlyaWdodCAoYykgMjAxNSBpbnN0cnVjdHVyZS1yZWFjdFxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuU09GVFdBUkUuXG4qL1xudmFyIHVuY2hlY2tlZEljb24gPSBSZWFjdC5jcmVhdGVFbGVtZW50KCdzdmcnLCB7XG4gIHZpZXdCb3g6IFwiLTIgLTUgMTQgMjBcIixcbiAgaGVpZ2h0OiBcIjEwMCVcIixcbiAgd2lkdGg6IFwiMTAwJVwiLFxuICBzdHlsZToge1xuICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgdG9wOiAwXG4gIH1cbn0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ3BhdGgnLCB7XG4gIGQ6IFwiTTkuOSAyLjEyTDcuNzggMCA0Ljk1IDIuODI4IDIuMTIgMCAwIDIuMTJsMi44MyAyLjgzTDAgNy43NzYgMi4xMjMgOS45IDQuOTUgNy4wNyA3Ljc4IDkuOSA5LjkgNy43NzYgNy4wNzIgNC45NSA5LjkgMi4xMlwiLFxuICBmaWxsOiBcIiNmZmZcIixcbiAgZmlsbFJ1bGU6IFwiZXZlbm9kZFwiXG59KSk7XG52YXIgY2hlY2tlZEljb24gPSBSZWFjdC5jcmVhdGVFbGVtZW50KCdzdmcnLCB7XG4gIGhlaWdodDogXCIxMDAlXCIsXG4gIHdpZHRoOiBcIjEwMCVcIixcbiAgdmlld0JveDogXCItMiAtNSAxNyAyMVwiLFxuICBzdHlsZToge1xuICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgdG9wOiAwXG4gIH1cbn0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ3BhdGgnLCB7XG4gIGQ6IFwiTTExLjI2NCAwTDUuMjYgNi4wMDQgMi4xMDMgMi44NDcgMCA0Ljk1bDUuMjYgNS4yNiA4LjEwOC04LjEwN0wxMS4yNjQgMFwiLFxuICBmaWxsOiBcIiNmZmZcIixcbiAgZmlsbFJ1bGU6IFwiZXZlbm9kZFwiXG59KSk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUJhY2tncm91bmRDb2xvcihwb3MsIGNoZWNrZWRQb3MsIHVuY2hlY2tlZFBvcywgb2ZmQ29sb3IsIG9uQ29sb3IpIHtcbiAgdmFyIHJlbGF0aXZlUG9zID0gKHBvcyAtIHVuY2hlY2tlZFBvcykgLyAoY2hlY2tlZFBvcyAtIHVuY2hlY2tlZFBvcyk7XG5cbiAgaWYgKHJlbGF0aXZlUG9zID09PSAwKSB7XG4gICAgcmV0dXJuIG9mZkNvbG9yO1xuICB9XG5cbiAgaWYgKHJlbGF0aXZlUG9zID09PSAxKSB7XG4gICAgcmV0dXJuIG9uQ29sb3I7XG4gIH1cblxuICB2YXIgbmV3Q29sb3IgPSBcIiNcIjtcblxuICBmb3IgKHZhciBpID0gMTsgaSA8IDY7IGkgKz0gMikge1xuICAgIHZhciBvZmZDb21wb25lbnQgPSBwYXJzZUludChvZmZDb2xvci5zdWJzdHIoaSwgMiksIDE2KTtcbiAgICB2YXIgb25Db21wb25lbnQgPSBwYXJzZUludChvbkNvbG9yLnN1YnN0cihpLCAyKSwgMTYpO1xuICAgIHZhciB3ZWlnaHRlZFZhbHVlID0gTWF0aC5yb3VuZCgoMSAtIHJlbGF0aXZlUG9zKSAqIG9mZkNvbXBvbmVudCArIHJlbGF0aXZlUG9zICogb25Db21wb25lbnQpO1xuICAgIHZhciBuZXdDb21wb25lbnQgPSB3ZWlnaHRlZFZhbHVlLnRvU3RyaW5nKDE2KTtcblxuICAgIGlmIChuZXdDb21wb25lbnQubGVuZ3RoID09PSAxKSB7XG4gICAgICBuZXdDb21wb25lbnQgPSBcIjBcIiArIG5ld0NvbXBvbmVudDtcbiAgICB9XG5cbiAgICBuZXdDb2xvciArPSBuZXdDb21wb25lbnQ7XG4gIH1cblxuICByZXR1cm4gbmV3Q29sb3I7XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRTaG9ydGhhbmRDb2xvcihjb2xvcikge1xuICBpZiAoY29sb3IubGVuZ3RoID09PSA3KSB7XG4gICAgcmV0dXJuIGNvbG9yO1xuICB9XG5cbiAgdmFyIHNpeERpZ2l0Q29sb3IgPSBcIiNcIjtcblxuICBmb3IgKHZhciBpID0gMTsgaSA8IDQ7IGkgKz0gMSkge1xuICAgIHNpeERpZ2l0Q29sb3IgKz0gY29sb3JbaV0gKyBjb2xvcltpXTtcbiAgfVxuXG4gIHJldHVybiBzaXhEaWdpdENvbG9yO1xufVxuXG5mdW5jdGlvbiBnZXRCYWNrZ3JvdW5kQ29sb3IocG9zLCBjaGVja2VkUG9zLCB1bmNoZWNrZWRQb3MsIG9mZkNvbG9yLCBvbkNvbG9yKSB7XG4gIHZhciBzaXhEaWdpdE9mZkNvbG9yID0gY29udmVydFNob3J0aGFuZENvbG9yKG9mZkNvbG9yKTtcbiAgdmFyIHNpeERpZ2l0T25Db2xvciA9IGNvbnZlcnRTaG9ydGhhbmRDb2xvcihvbkNvbG9yKTtcbiAgcmV0dXJuIGNyZWF0ZUJhY2tncm91bmRDb2xvcihwb3MsIGNoZWNrZWRQb3MsIHVuY2hlY2tlZFBvcywgc2l4RGlnaXRPZmZDb2xvciwgc2l4RGlnaXRPbkNvbG9yKTtcbn1cblxuLy8gTWFrZSBzdXJlIGNvbG9yIHByb3BzIGFyZSBzdHJpbmdzIHRoYXQgc3RhcnQgd2l0aCBcIiNcIiBzaW5jZSBvdGhlciB3YXlzIHRvIHdyaXRlIGNvbG9ycyBhcmUgbm90IHN1cHBvcnRlZC5cbnZhciBoZXhDb2xvclByb3BUeXBlID0gZnVuY3Rpb24gKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICB2YXIgcHJvcCA9IHByb3BzW3Byb3BOYW1lXTtcblxuICBpZiAodHlwZW9mIHByb3AgIT09IFwic3RyaW5nXCIgfHwgcHJvcFswXSAhPT0gXCIjXCIgfHwgcHJvcC5sZW5ndGggIT09IDQgJiYgcHJvcC5sZW5ndGggIT09IDcpIHtcbiAgICByZXR1cm4gbmV3IEVycm9yKFwiSW52YWxpZCBwcm9wICdcIiArIHByb3BOYW1lICsgXCInIHN1cHBsaWVkIHRvICdcIiArIGNvbXBvbmVudE5hbWUgKyBcIicuICdcIiArIHByb3BOYW1lICsgXCInIGhhcyB0byBiZSBlaXRoZXIgYSAzLWRpZ2l0IG9yIDYtZGlnaXQgaGV4LWNvbG9yIHN0cmluZy4gVmFsaWQgZXhhbXBsZXM6ICcjYWJjJywgJyMxMjM0NTYnXCIpO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59O1xuXG5mdW5jdGlvbiBvYmplY3RXaXRob3V0UHJvcGVydGllcyhvYmosIGV4Y2x1ZGUpIHtcbiAgdmFyIHRhcmdldCA9IHt9O1xuXG4gIGZvciAodmFyIGsgaW4gb2JqKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaykgJiYgZXhjbHVkZS5pbmRleE9mKGspID09PSAtMSkgdGFyZ2V0W2tdID0gb2JqW2tdO1xuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbnZhciBSZWFjdFN3aXRjaCA9IC8qQF9fUFVSRV9fKi9mdW5jdGlvbiAoQ29tcG9uZW50KSB7XG4gIGZ1bmN0aW9uIFJlYWN0U3dpdGNoKHByb3BzKSB7XG4gICAgQ29tcG9uZW50LmNhbGwodGhpcywgcHJvcHMpO1xuICAgIHZhciBoZWlnaHQgPSBwcm9wcy5oZWlnaHQ7XG4gICAgdmFyIHdpZHRoID0gcHJvcHMud2lkdGg7XG4gICAgdmFyIGhhbmRsZURpYW1ldGVyID0gcHJvcHMuaGFuZGxlRGlhbWV0ZXI7XG4gICAgdmFyIGNoZWNrZWQgPSBwcm9wcy5jaGVja2VkO1xuICAgIHRoaXMuJGhhbmRsZURpYW1ldGVyID0gaGFuZGxlRGlhbWV0ZXIgfHwgaGVpZ2h0IC0gMjtcbiAgICB0aGlzLiRjaGVja2VkUG9zID0gTWF0aC5tYXgod2lkdGggLSBoZWlnaHQsIHdpZHRoIC0gKGhlaWdodCArIHRoaXMuJGhhbmRsZURpYW1ldGVyKSAvIDIpO1xuICAgIHRoaXMuJHVuY2hlY2tlZFBvcyA9IE1hdGgubWF4KDAsIChoZWlnaHQgLSB0aGlzLiRoYW5kbGVEaWFtZXRlcikgLyAyKTtcbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgJHBvczogY2hlY2tlZCA/IHRoaXMuJGNoZWNrZWRQb3MgOiB0aGlzLiR1bmNoZWNrZWRQb3NcbiAgICB9O1xuICAgIHRoaXMuJGxhc3REcmFnQXQgPSAwO1xuICAgIHRoaXMuJGxhc3RLZXlVcEF0ID0gMDtcbiAgICB0aGlzLiRvbk1vdXNlRG93biA9IHRoaXMuJG9uTW91c2VEb3duLmJpbmQodGhpcyk7XG4gICAgdGhpcy4kb25Nb3VzZU1vdmUgPSB0aGlzLiRvbk1vdXNlTW92ZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMuJG9uTW91c2VVcCA9IHRoaXMuJG9uTW91c2VVcC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuJG9uVG91Y2hTdGFydCA9IHRoaXMuJG9uVG91Y2hTdGFydC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuJG9uVG91Y2hNb3ZlID0gdGhpcy4kb25Ub3VjaE1vdmUuYmluZCh0aGlzKTtcbiAgICB0aGlzLiRvblRvdWNoRW5kID0gdGhpcy4kb25Ub3VjaEVuZC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuJG9uQ2xpY2sgPSB0aGlzLiRvbkNsaWNrLmJpbmQodGhpcyk7XG4gICAgdGhpcy4kb25JbnB1dENoYW5nZSA9IHRoaXMuJG9uSW5wdXRDaGFuZ2UuYmluZCh0aGlzKTtcbiAgICB0aGlzLiRvbktleVVwID0gdGhpcy4kb25LZXlVcC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuJHNldEhhc091dGxpbmUgPSB0aGlzLiRzZXRIYXNPdXRsaW5lLmJpbmQodGhpcyk7XG4gICAgdGhpcy4kdW5zZXRIYXNPdXRsaW5lID0gdGhpcy4kdW5zZXRIYXNPdXRsaW5lLmJpbmQodGhpcyk7XG4gICAgdGhpcy4kZ2V0SW5wdXRSZWYgPSB0aGlzLiRnZXRJbnB1dFJlZi5iaW5kKHRoaXMpO1xuICB9XG5cbiAgaWYgKENvbXBvbmVudCkgUmVhY3RTd2l0Y2guX19wcm90b19fID0gQ29tcG9uZW50O1xuICBSZWFjdFN3aXRjaC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENvbXBvbmVudCAmJiBDb21wb25lbnQucHJvdG90eXBlKTtcbiAgUmVhY3RTd2l0Y2gucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmVhY3RTd2l0Y2g7XG5cbiAgUmVhY3RTd2l0Y2gucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgdGhpcy4kaXNNb3VudGVkID0gdHJ1ZTtcbiAgfTtcblxuICBSZWFjdFN3aXRjaC5wcm90b3R5cGUuY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xuICAgIGlmIChwcmV2UHJvcHMuY2hlY2tlZCA9PT0gdGhpcy5wcm9wcy5jaGVja2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyICRwb3MgPSB0aGlzLnByb3BzLmNoZWNrZWQgPyB0aGlzLiRjaGVja2VkUG9zIDogdGhpcy4kdW5jaGVja2VkUG9zO1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgJHBvczogJHBvc1xuICAgIH0pO1xuICB9O1xuXG4gIFJlYWN0U3dpdGNoLnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIHRoaXMuJGlzTW91bnRlZCA9IGZhbHNlO1xuICB9O1xuXG4gIFJlYWN0U3dpdGNoLnByb3RvdHlwZS4kb25EcmFnU3RhcnQgPSBmdW5jdGlvbiAkb25EcmFnU3RhcnQoY2xpZW50WCkge1xuICAgIHRoaXMuJGlucHV0UmVmLmZvY3VzKCk7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAkc3RhcnRYOiBjbGllbnRYLFxuICAgICAgJGhhc091dGxpbmU6IHRydWUsXG4gICAgICAkZHJhZ1N0YXJ0aW5nVGltZTogRGF0ZS5ub3coKVxuICAgIH0pO1xuICB9O1xuXG4gIFJlYWN0U3dpdGNoLnByb3RvdHlwZS4kb25EcmFnID0gZnVuY3Rpb24gJG9uRHJhZyhjbGllbnRYKSB7XG4gICAgdmFyIHJlZiA9IHRoaXMuc3RhdGU7XG4gICAgdmFyICRzdGFydFggPSByZWYuJHN0YXJ0WDtcbiAgICB2YXIgJGlzRHJhZ2dpbmcgPSByZWYuJGlzRHJhZ2dpbmc7XG4gICAgdmFyICRwb3MgPSByZWYuJHBvcztcbiAgICB2YXIgcmVmJDEgPSB0aGlzLnByb3BzO1xuICAgIHZhciBjaGVja2VkID0gcmVmJDEuY2hlY2tlZDtcbiAgICB2YXIgc3RhcnRQb3MgPSBjaGVja2VkID8gdGhpcy4kY2hlY2tlZFBvcyA6IHRoaXMuJHVuY2hlY2tlZFBvcztcbiAgICB2YXIgbW91c2VQb3MgPSBzdGFydFBvcyArIGNsaWVudFggLSAkc3RhcnRYOyAvLyBXZSBuZWVkIHRoaXMgY2hlY2sgdG8gZml4IGEgd2luZG93cyBnbGl0Y2ggd2hlcmUgb25EcmFnIGlzIHRyaWdnZXJlZCBvbk1vdXNlRG93biBpbiBzb21lIGNhc2VzXG5cbiAgICBpZiAoISRpc0RyYWdnaW5nICYmIGNsaWVudFggIT09ICRzdGFydFgpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAkaXNEcmFnZ2luZzogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIG5ld1BvcyA9IE1hdGgubWluKHRoaXMuJGNoZWNrZWRQb3MsIE1hdGgubWF4KHRoaXMuJHVuY2hlY2tlZFBvcywgbW91c2VQb3MpKTsgLy8gUHJldmVudCB1bm5lY2Vzc2FyeSByZXJlbmRlcnNcblxuICAgIGlmIChuZXdQb3MgIT09ICRwb3MpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAkcG9zOiBuZXdQb3NcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICBSZWFjdFN3aXRjaC5wcm90b3R5cGUuJG9uRHJhZ1N0b3AgPSBmdW5jdGlvbiAkb25EcmFnU3RvcChldmVudCkge1xuICAgIHZhciByZWYgPSB0aGlzLnN0YXRlO1xuICAgIHZhciAkcG9zID0gcmVmLiRwb3M7XG4gICAgdmFyICRpc0RyYWdnaW5nID0gcmVmLiRpc0RyYWdnaW5nO1xuICAgIHZhciAkZHJhZ1N0YXJ0aW5nVGltZSA9IHJlZi4kZHJhZ1N0YXJ0aW5nVGltZTtcbiAgICB2YXIgcmVmJDEgPSB0aGlzLnByb3BzO1xuICAgIHZhciBjaGVja2VkID0gcmVmJDEuY2hlY2tlZDtcbiAgICB2YXIgaGFsZndheUNoZWNrcG9pbnQgPSAodGhpcy4kY2hlY2tlZFBvcyArIHRoaXMuJHVuY2hlY2tlZFBvcykgLyAyO1xuICAgIC8qXG4gICAgICBTZXQgcG9zaXRpb24gc3RhdGUgYmFjayB0byB0aGUgcHJldmlvdXMgcG9zaXRpb24gZXZlbiBpZiB1c2VyIGRyYWdzIHRoZSBzd2l0Y2ggd2l0aCBpbnRlbnRpb24gdG8gY2hhbmdlIHRoZSBzdGF0ZS5cbiAgICAgIFRoaXMgaXMgdG8gcHJldmVudCB0aGUgc3dpdGNoIGZyb20gZ2V0dGluZyBzdHVjayBpbiB0aGUgbWlkZGxlIGlmIHRoZSBldmVudCBpc24ndCBoYW5kbGVkIGluIHRoZSBvbkNoYW5nZSBjYWxsYmFjay5cbiAgICAqL1xuXG4gICAgdmFyIHByZXZQb3MgPSB0aGlzLnByb3BzLmNoZWNrZWQgPyB0aGlzLiRjaGVja2VkUG9zIDogdGhpcy4kdW5jaGVja2VkUG9zO1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgJHBvczogcHJldlBvc1xuICAgIH0pOyAvLyBBY3QgYXMgaWYgdGhlIHVzZXIgY2xpY2tlZCB0aGUgaGFuZGxlIGlmIHRoZXkgZGlkbid0IGRyYWcgaXQgX29yXyB0aGUgZHJhZ2dlZCBpdCBmb3IgbGVzcyB0aGFuIDI1MG1zXG5cbiAgICB2YXIgdGltZVNpbmNlU3RhcnQgPSBEYXRlLm5vdygpIC0gJGRyYWdTdGFydGluZ1RpbWU7XG4gICAgdmFyIGlzU2ltdWxhdGVkQ2xpY2sgPSAhJGlzRHJhZ2dpbmcgfHwgdGltZVNpbmNlU3RhcnQgPCAyNTA7IC8vIEhhbmRsZSB3aGVuIHRoZSB1c2VyIGhhcyBkcmFnZ2VkIHRoZSBzd2l0Y2ggbW9yZSB0aGFuIGhhbGZ3YXkgZnJvbSBlaXRoZXIgc2lkZVxuXG4gICAgdmFyIGlzRHJhZ2dlZEhhbGZ3YXkgPSBjaGVja2VkICYmICRwb3MgPD0gaGFsZndheUNoZWNrcG9pbnQgfHwgIWNoZWNrZWQgJiYgJHBvcyA+PSBoYWxmd2F5Q2hlY2twb2ludDtcblxuICAgIGlmIChpc1NpbXVsYXRlZENsaWNrIHx8IGlzRHJhZ2dlZEhhbGZ3YXkpIHtcbiAgICAgIHRoaXMuJG9uQ2hhbmdlKGV2ZW50KTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy4kaXNNb3VudGVkKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgJGlzRHJhZ2dpbmc6IGZhbHNlLFxuICAgICAgICAkaGFzT3V0bGluZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuJGxhc3REcmFnQXQgPSBEYXRlLm5vdygpO1xuICB9O1xuXG4gIFJlYWN0U3dpdGNoLnByb3RvdHlwZS4kb25Nb3VzZURvd24gPSBmdW5jdGlvbiAkb25Nb3VzZURvd24oZXZlbnQpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpOyAvLyBJZ25vcmUgcmlnaHQgY2xpY2sgYW5kIHNjcm9sbFxuXG4gICAgaWYgKHR5cGVvZiBldmVudC5idXR0b24gPT09IFwibnVtYmVyXCIgJiYgZXZlbnQuYnV0dG9uICE9PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy4kb25EcmFnU3RhcnQoZXZlbnQuY2xpZW50WCk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgdGhpcy4kb25Nb3VzZU1vdmUpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCB0aGlzLiRvbk1vdXNlVXApO1xuICB9O1xuXG4gIFJlYWN0U3dpdGNoLnByb3RvdHlwZS4kb25Nb3VzZU1vdmUgPSBmdW5jdGlvbiAkb25Nb3VzZU1vdmUoZXZlbnQpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHRoaXMuJG9uRHJhZyhldmVudC5jbGllbnRYKTtcbiAgfTtcblxuICBSZWFjdFN3aXRjaC5wcm90b3R5cGUuJG9uTW91c2VVcCA9IGZ1bmN0aW9uICRvbk1vdXNlVXAoZXZlbnQpIHtcbiAgICB0aGlzLiRvbkRyYWdTdG9wKGV2ZW50KTtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCB0aGlzLiRvbk1vdXNlTW92ZSk7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIHRoaXMuJG9uTW91c2VVcCk7XG4gIH07XG5cbiAgUmVhY3RTd2l0Y2gucHJvdG90eXBlLiRvblRvdWNoU3RhcnQgPSBmdW5jdGlvbiAkb25Ub3VjaFN0YXJ0KGV2ZW50KSB7XG4gICAgdGhpcy4kY2hlY2tlZFN0YXRlRnJvbURyYWdnaW5nID0gbnVsbDtcbiAgICB0aGlzLiRvbkRyYWdTdGFydChldmVudC50b3VjaGVzWzBdLmNsaWVudFgpO1xuICB9O1xuXG4gIFJlYWN0U3dpdGNoLnByb3RvdHlwZS4kb25Ub3VjaE1vdmUgPSBmdW5jdGlvbiAkb25Ub3VjaE1vdmUoZXZlbnQpIHtcbiAgICB0aGlzLiRvbkRyYWcoZXZlbnQudG91Y2hlc1swXS5jbGllbnRYKTtcbiAgfTtcblxuICBSZWFjdFN3aXRjaC5wcm90b3R5cGUuJG9uVG91Y2hFbmQgPSBmdW5jdGlvbiAkb25Ub3VjaEVuZChldmVudCkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgdGhpcy4kb25EcmFnU3RvcChldmVudCk7XG4gIH07XG5cbiAgUmVhY3RTd2l0Y2gucHJvdG90eXBlLiRvbklucHV0Q2hhbmdlID0gZnVuY3Rpb24gJG9uSW5wdXRDaGFuZ2UoZXZlbnQpIHtcbiAgICAvLyBUaGlzIGNvbmRpdGlvbiBpcyB1bmZvcnR1bmF0ZWx5IG5lZWRlZCBpbiBzb21lIGJyb3dzZXJzIHdoZXJlIHRoZSBpbnB1dCdzIGNoYW5nZSBldmVudCBtaWdodCBnZXQgdHJpZ2dlcmVkXG4gICAgLy8gcmlnaHQgYWZ0ZXIgdGhlIGRyYWdzdG9wIGV2ZW50IGlzIHRyaWdnZXJlZCAob2NjdXJzIHdoZW4gZHJvcHBpbmcgb3ZlciBhIGxhYmVsIGVsZW1lbnQpXG4gICAgaWYgKERhdGUubm93KCkgLSB0aGlzLiRsYXN0RHJhZ0F0ID4gNTApIHtcbiAgICAgIHRoaXMuJG9uQ2hhbmdlKGV2ZW50KTsgLy8gUHJldmVudCBjbGlja2luZyBsYWJlbCwgYnV0IG5vdCBrZXkgYWN0aXZhdGlvbiBmcm9tIHNldHRpbmcgb3V0bGluZSB0byB0cnVlIC0geWVzLCB0aGlzIGlzIGFic3VyZFxuXG4gICAgICBpZiAoRGF0ZS5ub3coKSAtIHRoaXMuJGxhc3RLZXlVcEF0ID4gNTApIHtcbiAgICAgICAgaWYgKHRoaXMuJGlzTW91bnRlZCkge1xuICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgJGhhc091dGxpbmU6IGZhbHNlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgUmVhY3RTd2l0Y2gucHJvdG90eXBlLiRvbktleVVwID0gZnVuY3Rpb24gJG9uS2V5VXAoKSB7XG4gICAgdGhpcy4kbGFzdEtleVVwQXQgPSBEYXRlLm5vdygpO1xuICB9O1xuXG4gIFJlYWN0U3dpdGNoLnByb3RvdHlwZS4kc2V0SGFzT3V0bGluZSA9IGZ1bmN0aW9uICRzZXRIYXNPdXRsaW5lKCkge1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgJGhhc091dGxpbmU6IHRydWVcbiAgICB9KTtcbiAgfTtcblxuICBSZWFjdFN3aXRjaC5wcm90b3R5cGUuJHVuc2V0SGFzT3V0bGluZSA9IGZ1bmN0aW9uICR1bnNldEhhc091dGxpbmUoKSB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAkaGFzT3V0bGluZTogZmFsc2VcbiAgICB9KTtcbiAgfTtcblxuICBSZWFjdFN3aXRjaC5wcm90b3R5cGUuJGdldElucHV0UmVmID0gZnVuY3Rpb24gJGdldElucHV0UmVmKGVsKSB7XG4gICAgdGhpcy4kaW5wdXRSZWYgPSBlbDtcbiAgfTtcblxuICBSZWFjdFN3aXRjaC5wcm90b3R5cGUuJG9uQ2xpY2sgPSBmdW5jdGlvbiAkb25DbGljayhldmVudCkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgdGhpcy4kaW5wdXRSZWYuZm9jdXMoKTtcbiAgICB0aGlzLiRvbkNoYW5nZShldmVudCk7XG5cbiAgICBpZiAodGhpcy4kaXNNb3VudGVkKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgJGhhc091dGxpbmU6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgUmVhY3RTd2l0Y2gucHJvdG90eXBlLiRvbkNoYW5nZSA9IGZ1bmN0aW9uICRvbkNoYW5nZShldmVudCkge1xuICAgIHZhciByZWYgPSB0aGlzLnByb3BzO1xuICAgIHZhciBjaGVja2VkID0gcmVmLmNoZWNrZWQ7XG4gICAgdmFyIG9uQ2hhbmdlID0gcmVmLm9uQ2hhbmdlO1xuICAgIHZhciBpZCA9IHJlZi5pZDtcbiAgICBvbkNoYW5nZSghY2hlY2tlZCwgZXZlbnQsIGlkKTtcbiAgfTtcblxuICBSZWFjdFN3aXRjaC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciByZWYgPSB0aGlzLnByb3BzO1xuICAgIHZhciBjaGVja2VkID0gcmVmLmNoZWNrZWQ7XG4gICAgdmFyIGRpc2FibGVkID0gcmVmLmRpc2FibGVkO1xuICAgIHZhciBjbGFzc05hbWUgPSByZWYuY2xhc3NOYW1lO1xuICAgIHZhciBvZmZDb2xvciA9IHJlZi5vZmZDb2xvcjtcbiAgICB2YXIgb25Db2xvciA9IHJlZi5vbkNvbG9yO1xuICAgIHZhciBvZmZIYW5kbGVDb2xvciA9IHJlZi5vZmZIYW5kbGVDb2xvcjtcbiAgICB2YXIgb25IYW5kbGVDb2xvciA9IHJlZi5vbkhhbmRsZUNvbG9yO1xuICAgIHZhciBjaGVja2VkSWNvbiA9IHJlZi5jaGVja2VkSWNvbjtcbiAgICB2YXIgdW5jaGVja2VkSWNvbiA9IHJlZi51bmNoZWNrZWRJY29uO1xuICAgIHZhciBjaGVja2VkSGFuZGxlSWNvbiA9IHJlZi5jaGVja2VkSGFuZGxlSWNvbjtcbiAgICB2YXIgdW5jaGVja2VkSGFuZGxlSWNvbiA9IHJlZi51bmNoZWNrZWRIYW5kbGVJY29uO1xuICAgIHZhciBib3hTaGFkb3cgPSByZWYuYm94U2hhZG93O1xuICAgIHZhciBhY3RpdmVCb3hTaGFkb3cgPSByZWYuYWN0aXZlQm94U2hhZG93O1xuICAgIHZhciBoZWlnaHQgPSByZWYuaGVpZ2h0O1xuICAgIHZhciB3aWR0aCA9IHJlZi53aWR0aDtcbiAgICB2YXIgYm9yZGVyUmFkaXVzID0gcmVmLmJvcmRlclJhZGl1cztcbiAgICByZWYuaGFuZGxlRGlhbWV0ZXI7XG4gICAgdmFyIHJlc3QkMSA9IG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHJlZiwgW1wiY2hlY2tlZFwiLCBcImRpc2FibGVkXCIsIFwiY2xhc3NOYW1lXCIsIFwib2ZmQ29sb3JcIiwgXCJvbkNvbG9yXCIsIFwib2ZmSGFuZGxlQ29sb3JcIiwgXCJvbkhhbmRsZUNvbG9yXCIsIFwiY2hlY2tlZEljb25cIiwgXCJ1bmNoZWNrZWRJY29uXCIsIFwiY2hlY2tlZEhhbmRsZUljb25cIiwgXCJ1bmNoZWNrZWRIYW5kbGVJY29uXCIsIFwiYm94U2hhZG93XCIsIFwiYWN0aXZlQm94U2hhZG93XCIsIFwiaGVpZ2h0XCIsIFwid2lkdGhcIiwgXCJib3JkZXJSYWRpdXNcIiwgXCJoYW5kbGVEaWFtZXRlclwiXSk7XG4gICAgdmFyIHJlc3QgPSByZXN0JDE7XG4gICAgdmFyIHJlZiQxID0gdGhpcy5zdGF0ZTtcbiAgICB2YXIgJHBvcyA9IHJlZiQxLiRwb3M7XG4gICAgdmFyICRpc0RyYWdnaW5nID0gcmVmJDEuJGlzRHJhZ2dpbmc7XG4gICAgdmFyICRoYXNPdXRsaW5lID0gcmVmJDEuJGhhc091dGxpbmU7XG4gICAgdmFyIHJvb3RTdHlsZSA9IHtcbiAgICAgIHBvc2l0aW9uOiBcInJlbGF0aXZlXCIsXG4gICAgICBkaXNwbGF5OiBcImlubGluZS1ibG9ja1wiLFxuICAgICAgdGV4dEFsaWduOiBcImxlZnRcIixcbiAgICAgIG9wYWNpdHk6IGRpc2FibGVkID8gMC41IDogMSxcbiAgICAgIGRpcmVjdGlvbjogXCJsdHJcIixcbiAgICAgIGJvcmRlclJhZGl1czogaGVpZ2h0IC8gMixcbiAgICAgIFdlYmtpdFRyYW5zaXRpb246IFwib3BhY2l0eSAwLjI1c1wiLFxuICAgICAgTW96VHJhbnNpdGlvbjogXCJvcGFjaXR5IDAuMjVzXCIsXG4gICAgICB0cmFuc2l0aW9uOiBcIm9wYWNpdHkgMC4yNXNcIixcbiAgICAgIHRvdWNoQWN0aW9uOiBcIm5vbmVcIixcbiAgICAgIFdlYmtpdFRhcEhpZ2hsaWdodENvbG9yOiBcInJnYmEoMCwgMCwgMCwgMClcIixcbiAgICAgIFdlYmtpdFVzZXJTZWxlY3Q6IFwibm9uZVwiLFxuICAgICAgTW96VXNlclNlbGVjdDogXCJub25lXCIsXG4gICAgICBtc1VzZXJTZWxlY3Q6IFwibm9uZVwiLFxuICAgICAgdXNlclNlbGVjdDogXCJub25lXCJcbiAgICB9O1xuICAgIHZhciBiYWNrZ3JvdW5kU3R5bGUgPSB7XG4gICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgIG1hcmdpbjogTWF0aC5tYXgoMCwgKHRoaXMuJGhhbmRsZURpYW1ldGVyIC0gaGVpZ2h0KSAvIDIpLFxuICAgICAgcG9zaXRpb246IFwicmVsYXRpdmVcIixcbiAgICAgIGJhY2tncm91bmQ6IGdldEJhY2tncm91bmRDb2xvcigkcG9zLCB0aGlzLiRjaGVja2VkUG9zLCB0aGlzLiR1bmNoZWNrZWRQb3MsIG9mZkNvbG9yLCBvbkNvbG9yKSxcbiAgICAgIGJvcmRlclJhZGl1czogdHlwZW9mIGJvcmRlclJhZGl1cyA9PT0gXCJudW1iZXJcIiA/IGJvcmRlclJhZGl1cyA6IGhlaWdodCAvIDIsXG4gICAgICBjdXJzb3I6IGRpc2FibGVkID8gXCJkZWZhdWx0XCIgOiBcInBvaW50ZXJcIixcbiAgICAgIFdlYmtpdFRyYW5zaXRpb246ICRpc0RyYWdnaW5nID8gbnVsbCA6IFwiYmFja2dyb3VuZCAwLjI1c1wiLFxuICAgICAgTW96VHJhbnNpdGlvbjogJGlzRHJhZ2dpbmcgPyBudWxsIDogXCJiYWNrZ3JvdW5kIDAuMjVzXCIsXG4gICAgICB0cmFuc2l0aW9uOiAkaXNEcmFnZ2luZyA/IG51bGwgOiBcImJhY2tncm91bmQgMC4yNXNcIlxuICAgIH07XG4gICAgdmFyIGNoZWNrZWRJY29uU3R5bGUgPSB7XG4gICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgIHdpZHRoOiBNYXRoLm1pbihoZWlnaHQgKiAxLjUsIHdpZHRoIC0gKHRoaXMuJGhhbmRsZURpYW1ldGVyICsgaGVpZ2h0KSAvIDIgKyAxKSxcbiAgICAgIHBvc2l0aW9uOiBcInJlbGF0aXZlXCIsXG4gICAgICBvcGFjaXR5OiAoJHBvcyAtIHRoaXMuJHVuY2hlY2tlZFBvcykgLyAodGhpcy4kY2hlY2tlZFBvcyAtIHRoaXMuJHVuY2hlY2tlZFBvcyksXG4gICAgICBwb2ludGVyRXZlbnRzOiBcIm5vbmVcIixcbiAgICAgIFdlYmtpdFRyYW5zaXRpb246ICRpc0RyYWdnaW5nID8gbnVsbCA6IFwib3BhY2l0eSAwLjI1c1wiLFxuICAgICAgTW96VHJhbnNpdGlvbjogJGlzRHJhZ2dpbmcgPyBudWxsIDogXCJvcGFjaXR5IDAuMjVzXCIsXG4gICAgICB0cmFuc2l0aW9uOiAkaXNEcmFnZ2luZyA/IG51bGwgOiBcIm9wYWNpdHkgMC4yNXNcIlxuICAgIH07XG4gICAgdmFyIHVuY2hlY2tlZEljb25TdHlsZSA9IHtcbiAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgd2lkdGg6IE1hdGgubWluKGhlaWdodCAqIDEuNSwgd2lkdGggLSAodGhpcy4kaGFuZGxlRGlhbWV0ZXIgKyBoZWlnaHQpIC8gMiArIDEpLFxuICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgIG9wYWNpdHk6IDEgLSAoJHBvcyAtIHRoaXMuJHVuY2hlY2tlZFBvcykgLyAodGhpcy4kY2hlY2tlZFBvcyAtIHRoaXMuJHVuY2hlY2tlZFBvcyksXG4gICAgICByaWdodDogMCxcbiAgICAgIHRvcDogMCxcbiAgICAgIHBvaW50ZXJFdmVudHM6IFwibm9uZVwiLFxuICAgICAgV2Via2l0VHJhbnNpdGlvbjogJGlzRHJhZ2dpbmcgPyBudWxsIDogXCJvcGFjaXR5IDAuMjVzXCIsXG4gICAgICBNb3pUcmFuc2l0aW9uOiAkaXNEcmFnZ2luZyA/IG51bGwgOiBcIm9wYWNpdHkgMC4yNXNcIixcbiAgICAgIHRyYW5zaXRpb246ICRpc0RyYWdnaW5nID8gbnVsbCA6IFwib3BhY2l0eSAwLjI1c1wiXG4gICAgfTtcbiAgICB2YXIgaGFuZGxlU3R5bGUgPSB7XG4gICAgICBoZWlnaHQ6IHRoaXMuJGhhbmRsZURpYW1ldGVyLFxuICAgICAgd2lkdGg6IHRoaXMuJGhhbmRsZURpYW1ldGVyLFxuICAgICAgYmFja2dyb3VuZDogZ2V0QmFja2dyb3VuZENvbG9yKCRwb3MsIHRoaXMuJGNoZWNrZWRQb3MsIHRoaXMuJHVuY2hlY2tlZFBvcywgb2ZmSGFuZGxlQ29sb3IsIG9uSGFuZGxlQ29sb3IpLFxuICAgICAgZGlzcGxheTogXCJpbmxpbmUtYmxvY2tcIixcbiAgICAgIGN1cnNvcjogZGlzYWJsZWQgPyBcImRlZmF1bHRcIiA6IFwicG9pbnRlclwiLFxuICAgICAgYm9yZGVyUmFkaXVzOiB0eXBlb2YgYm9yZGVyUmFkaXVzID09PSBcIm51bWJlclwiID8gYm9yZGVyUmFkaXVzIC0gMSA6IFwiNTAlXCIsXG4gICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZVgoXCIgKyAkcG9zICsgXCJweClcIixcbiAgICAgIHRvcDogTWF0aC5tYXgoMCwgKGhlaWdodCAtIHRoaXMuJGhhbmRsZURpYW1ldGVyKSAvIDIpLFxuICAgICAgb3V0bGluZTogMCxcbiAgICAgIGJveFNoYWRvdzogJGhhc091dGxpbmUgPyBhY3RpdmVCb3hTaGFkb3cgOiBib3hTaGFkb3csXG4gICAgICBib3JkZXI6IDAsXG4gICAgICBXZWJraXRUcmFuc2l0aW9uOiAkaXNEcmFnZ2luZyA/IG51bGwgOiBcImJhY2tncm91bmQtY29sb3IgMC4yNXMsIHRyYW5zZm9ybSAwLjI1cywgYm94LXNoYWRvdyAwLjE1c1wiLFxuICAgICAgTW96VHJhbnNpdGlvbjogJGlzRHJhZ2dpbmcgPyBudWxsIDogXCJiYWNrZ3JvdW5kLWNvbG9yIDAuMjVzLCB0cmFuc2Zvcm0gMC4yNXMsIGJveC1zaGFkb3cgMC4xNXNcIixcbiAgICAgIHRyYW5zaXRpb246ICRpc0RyYWdnaW5nID8gbnVsbCA6IFwiYmFja2dyb3VuZC1jb2xvciAwLjI1cywgdHJhbnNmb3JtIDAuMjVzLCBib3gtc2hhZG93IDAuMTVzXCJcbiAgICB9O1xuICAgIHZhciB1bmNoZWNrZWRIYW5kbGVJY29uU3R5bGUgPSB7XG4gICAgICBoZWlnaHQ6IHRoaXMuJGhhbmRsZURpYW1ldGVyLFxuICAgICAgd2lkdGg6IHRoaXMuJGhhbmRsZURpYW1ldGVyLFxuICAgICAgb3BhY2l0eTogTWF0aC5tYXgoKDEgLSAoJHBvcyAtIHRoaXMuJHVuY2hlY2tlZFBvcykgLyAodGhpcy4kY2hlY2tlZFBvcyAtIHRoaXMuJHVuY2hlY2tlZFBvcykgLSAwLjUpICogMiwgMCksXG4gICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgICAgbGVmdDogMCxcbiAgICAgIHRvcDogMCxcbiAgICAgIHBvaW50ZXJFdmVudHM6IFwibm9uZVwiLFxuICAgICAgV2Via2l0VHJhbnNpdGlvbjogJGlzRHJhZ2dpbmcgPyBudWxsIDogXCJvcGFjaXR5IDAuMjVzXCIsXG4gICAgICBNb3pUcmFuc2l0aW9uOiAkaXNEcmFnZ2luZyA/IG51bGwgOiBcIm9wYWNpdHkgMC4yNXNcIixcbiAgICAgIHRyYW5zaXRpb246ICRpc0RyYWdnaW5nID8gbnVsbCA6IFwib3BhY2l0eSAwLjI1c1wiXG4gICAgfTtcbiAgICB2YXIgY2hlY2tlZEhhbmRsZUljb25TdHlsZSA9IHtcbiAgICAgIGhlaWdodDogdGhpcy4kaGFuZGxlRGlhbWV0ZXIsXG4gICAgICB3aWR0aDogdGhpcy4kaGFuZGxlRGlhbWV0ZXIsXG4gICAgICBvcGFjaXR5OiBNYXRoLm1heCgoKCRwb3MgLSB0aGlzLiR1bmNoZWNrZWRQb3MpIC8gKHRoaXMuJGNoZWNrZWRQb3MgLSB0aGlzLiR1bmNoZWNrZWRQb3MpIC0gMC41KSAqIDIsIDApLFxuICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgIGxlZnQ6IDAsXG4gICAgICB0b3A6IDAsXG4gICAgICBwb2ludGVyRXZlbnRzOiBcIm5vbmVcIixcbiAgICAgIFdlYmtpdFRyYW5zaXRpb246ICRpc0RyYWdnaW5nID8gbnVsbCA6IFwib3BhY2l0eSAwLjI1c1wiLFxuICAgICAgTW96VHJhbnNpdGlvbjogJGlzRHJhZ2dpbmcgPyBudWxsIDogXCJvcGFjaXR5IDAuMjVzXCIsXG4gICAgICB0cmFuc2l0aW9uOiAkaXNEcmFnZ2luZyA/IG51bGwgOiBcIm9wYWNpdHkgMC4yNXNcIlxuICAgIH07XG4gICAgdmFyIGlucHV0U3R5bGUgPSB7XG4gICAgICBib3JkZXI6IDAsXG4gICAgICBjbGlwOiBcInJlY3QoMCAwIDAgMClcIixcbiAgICAgIGhlaWdodDogMSxcbiAgICAgIG1hcmdpbjogLTEsXG4gICAgICBvdmVyZmxvdzogXCJoaWRkZW5cIixcbiAgICAgIHBhZGRpbmc6IDAsXG4gICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgICAgd2lkdGg6IDFcbiAgICB9O1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KCdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZSxcbiAgICAgIHN0eWxlOiByb290U3R5bGVcbiAgICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KCdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6IFwicmVhY3Qtc3dpdGNoLWJnXCIsXG4gICAgICBzdHlsZTogYmFja2dyb3VuZFN0eWxlLFxuICAgICAgb25DbGljazogZGlzYWJsZWQgPyBudWxsIDogdGhpcy4kb25DbGljayxcbiAgICAgIG9uTW91c2VEb3duOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICByZXR1cm4gZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgIH0sIGNoZWNrZWRJY29uICYmIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ2RpdicsIHtcbiAgICAgIHN0eWxlOiBjaGVja2VkSWNvblN0eWxlXG4gICAgfSwgY2hlY2tlZEljb24pLCB1bmNoZWNrZWRJY29uICYmIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ2RpdicsIHtcbiAgICAgIHN0eWxlOiB1bmNoZWNrZWRJY29uU3R5bGVcbiAgICB9LCB1bmNoZWNrZWRJY29uKSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogXCJyZWFjdC1zd2l0Y2gtaGFuZGxlXCIsXG4gICAgICBzdHlsZTogaGFuZGxlU3R5bGUsXG4gICAgICBvbkNsaWNrOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICByZXR1cm4gZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfSxcbiAgICAgIG9uTW91c2VEb3duOiBkaXNhYmxlZCA/IG51bGwgOiB0aGlzLiRvbk1vdXNlRG93bixcbiAgICAgIG9uVG91Y2hTdGFydDogZGlzYWJsZWQgPyBudWxsIDogdGhpcy4kb25Ub3VjaFN0YXJ0LFxuICAgICAgb25Ub3VjaE1vdmU6IGRpc2FibGVkID8gbnVsbCA6IHRoaXMuJG9uVG91Y2hNb3ZlLFxuICAgICAgb25Ub3VjaEVuZDogZGlzYWJsZWQgPyBudWxsIDogdGhpcy4kb25Ub3VjaEVuZCxcbiAgICAgIG9uVG91Y2hDYW5jZWw6IGRpc2FibGVkID8gbnVsbCA6IHRoaXMuJHVuc2V0SGFzT3V0bGluZVxuICAgIH0sIHVuY2hlY2tlZEhhbmRsZUljb24gJiYgUmVhY3QuY3JlYXRlRWxlbWVudCgnZGl2Jywge1xuICAgICAgc3R5bGU6IHVuY2hlY2tlZEhhbmRsZUljb25TdHlsZVxuICAgIH0sIHVuY2hlY2tlZEhhbmRsZUljb24pLCBjaGVja2VkSGFuZGxlSWNvbiAmJiBSZWFjdC5jcmVhdGVFbGVtZW50KCdkaXYnLCB7XG4gICAgICBzdHlsZTogY2hlY2tlZEhhbmRsZUljb25TdHlsZVxuICAgIH0sIGNoZWNrZWRIYW5kbGVJY29uKSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ2lucHV0JywgX2V4dGVuZHMoe30sIHtcbiAgICAgIHR5cGU6IFwiY2hlY2tib3hcIixcbiAgICAgIHJvbGU6IFwic3dpdGNoXCIsXG4gICAgICAnYXJpYS1jaGVja2VkJzogY2hlY2tlZCxcbiAgICAgIGNoZWNrZWQ6IGNoZWNrZWQsXG4gICAgICBkaXNhYmxlZDogZGlzYWJsZWQsXG4gICAgICBzdHlsZTogaW5wdXRTdHlsZVxuICAgIH0sIHJlc3QsIHtcbiAgICAgIHJlZjogdGhpcy4kZ2V0SW5wdXRSZWYsXG4gICAgICBvbkZvY3VzOiB0aGlzLiRzZXRIYXNPdXRsaW5lLFxuICAgICAgb25CbHVyOiB0aGlzLiR1bnNldEhhc091dGxpbmUsXG4gICAgICBvbktleVVwOiB0aGlzLiRvbktleVVwLFxuICAgICAgb25DaGFuZ2U6IHRoaXMuJG9uSW5wdXRDaGFuZ2VcbiAgICB9KSkpO1xuICB9O1xuXG4gIHJldHVybiBSZWFjdFN3aXRjaDtcbn0oQ29tcG9uZW50KTtcblxuUmVhY3RTd2l0Y2gucHJvcFR5cGVzID0ge1xuICBjaGVja2VkOiBQcm9wVHlwZXMuYm9vbC5pc1JlcXVpcmVkLFxuICBvbkNoYW5nZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgZGlzYWJsZWQ6IFByb3BUeXBlcy5ib29sLFxuICBvZmZDb2xvcjogaGV4Q29sb3JQcm9wVHlwZSxcbiAgb25Db2xvcjogaGV4Q29sb3JQcm9wVHlwZSxcbiAgb2ZmSGFuZGxlQ29sb3I6IGhleENvbG9yUHJvcFR5cGUsXG4gIG9uSGFuZGxlQ29sb3I6IGhleENvbG9yUHJvcFR5cGUsXG4gIGhhbmRsZURpYW1ldGVyOiBQcm9wVHlwZXMubnVtYmVyLFxuICB1bmNoZWNrZWRJY29uOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuYm9vbCwgUHJvcFR5cGVzLmVsZW1lbnRdKSxcbiAgY2hlY2tlZEljb246IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5ib29sLCBQcm9wVHlwZXMuZWxlbWVudF0pLFxuICBib3hTaGFkb3c6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGJvcmRlclJhZGl1czogUHJvcFR5cGVzLm51bWJlcixcbiAgYWN0aXZlQm94U2hhZG93OiBQcm9wVHlwZXMuc3RyaW5nLFxuICB1bmNoZWNrZWRIYW5kbGVJY29uOiBQcm9wVHlwZXMuZWxlbWVudCxcbiAgY2hlY2tlZEhhbmRsZUljb246IFByb3BUeXBlcy5lbGVtZW50LFxuICBoZWlnaHQ6IFByb3BUeXBlcy5udW1iZXIsXG4gIHdpZHRoOiBQcm9wVHlwZXMubnVtYmVyLFxuICBpZDogUHJvcFR5cGVzLnN0cmluZyxcbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nXG59O1xuUmVhY3RTd2l0Y2guZGVmYXVsdFByb3BzID0ge1xuICBkaXNhYmxlZDogZmFsc2UsXG4gIG9mZkNvbG9yOiBcIiM4ODhcIixcbiAgb25Db2xvcjogXCIjMDgwXCIsXG4gIG9mZkhhbmRsZUNvbG9yOiBcIiNmZmZcIixcbiAgb25IYW5kbGVDb2xvcjogXCIjZmZmXCIsXG4gIHVuY2hlY2tlZEljb246IHVuY2hlY2tlZEljb24sXG4gIGNoZWNrZWRJY29uOiBjaGVja2VkSWNvbixcbiAgYm94U2hhZG93OiBudWxsLFxuICBhY3RpdmVCb3hTaGFkb3c6IFwiMCAwIDJweCAzcHggIzNiZlwiLFxuICBoZWlnaHQ6IDI4LFxuICB3aWR0aDogNTZcbn07XG5cbmV4cG9ydCB7IFJlYWN0U3dpdGNoIGFzIGRlZmF1bHQgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==