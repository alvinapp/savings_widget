"use strict";
(self["webpackChunksavings_widget"] = self["webpackChunksavings_widget"] || []).push([["vendors-node_modules_react-slider_dist_es_dev_components_ReactSlider_ReactSlider_mjs"],{

/***/ "./node_modules/react-slider/dist/es/dev/components/ReactSlider/ReactSlider.mjs":
/*!**************************************************************************************!*\
  !*** ./node_modules/react-slider/dist/es/dev/components/ReactSlider/ReactSlider.mjs ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ReactSlider$1)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/extends */ "./node_modules/@babel/runtime/helpers/esm/extends.js");
/* harmony import */ var _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/inheritsLoose */ "./node_modules/@babel/runtime/helpers/esm/inheritsLoose.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");





var _jsxFileName = "/Users/krise/github/react-slider/src/components/ReactSlider/ReactSlider.jsx";
/**
 * To prevent text selection while dragging.
 * http://stackoverflow.com/questions/5429827/how-can-i-prevent-text-element-selection-with-cursor-drag
 */

function pauseEvent(e) {
  if (e && e.stopPropagation) {
    e.stopPropagation();
  }

  if (e && e.preventDefault) {
    e.preventDefault();
  }

  return false;
}

function stopPropagation(e) {
  if (e.stopPropagation) {
    e.stopPropagation();
  }
}

function sanitizeInValue(x) {
  if (x == null) {
    return [];
  }

  return Array.isArray(x) ? x.slice() : [x];
}

function prepareOutValue(x) {
  return x !== null && x.length === 1 ? x[0] : x.slice();
}

function trimSucceeding(length, nextValue, minDistance, max) {
  for (let i = 0; i < length; i += 1) {
    const padding = max - i * minDistance;

    if (nextValue[length - 1 - i] > padding) {
      // eslint-disable-next-line no-param-reassign
      nextValue[length - 1 - i] = padding;
    }
  }
}

function trimPreceding(length, nextValue, minDistance, min) {
  for (let i = 0; i < length; i += 1) {
    const padding = min + i * minDistance;

    if (nextValue[i] < padding) {
      // eslint-disable-next-line no-param-reassign
      nextValue[i] = padding;
    }
  }
}

function addHandlers(eventMap) {
  Object.keys(eventMap).forEach(key => {
    if (typeof document !== 'undefined') {
      document.addEventListener(key, eventMap[key], false);
    }
  });
}

function removeHandlers(eventMap) {
  Object.keys(eventMap).forEach(key => {
    if (typeof document !== 'undefined') {
      document.removeEventListener(key, eventMap[key], false);
    }
  });
}

function trimAlignValue(val, props) {
  return alignValue(trimValue(val, props), props);
}

function alignValue(val, props) {
  const valModStep = (val - props.min) % props.step;
  let alignedValue = val - valModStep;

  if (Math.abs(valModStep) * 2 >= props.step) {
    alignedValue += valModStep > 0 ? props.step : -props.step;
  }

  return parseFloat(alignedValue.toFixed(5));
}

function trimValue(val, props) {
  let trimmed = val;

  if (trimmed <= props.min) {
    trimmed = props.min;
  }

  if (trimmed >= props.max) {
    trimmed = props.max;
  }

  return trimmed;
}

let ReactSlider = /*#__PURE__*/function (_React$Component) {
  (0,_babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_1__["default"])(ReactSlider, _React$Component);

  function ReactSlider(_props) {
    var _this;

    _this = _React$Component.call(this, _props) || this;

    _this.onKeyUp = () => {
      _this.onEnd();
    };

    _this.onMouseUp = () => {
      _this.onEnd(_this.getMouseEventMap());
    };

    _this.onTouchEnd = () => {
      _this.onEnd(_this.getTouchEventMap());
    };

    _this.onBlur = () => {
      _this.setState({
        index: -1
      }, _this.onEnd(_this.getKeyDownEventMap()));
    };

    _this.onMouseMove = e => {
      // Prevent controlled updates from happening while mouse is moving
      _this.setState({
        pending: true
      });

      const position = _this.getMousePosition(e);

      const diffPosition = _this.getDiffPosition(position[0]);

      const newValue = _this.getValueFromPosition(diffPosition);

      _this.move(newValue);
    };

    _this.onTouchMove = e => {
      if (e.touches.length > 1) {
        return;
      } // Prevent controlled updates from happending while touch is moving


      _this.setState({
        pending: true
      });

      const position = _this.getTouchPosition(e);

      if (typeof _this.isScrolling === 'undefined') {
        const diffMainDir = position[0] - _this.startPosition[0];
        const diffScrollDir = position[1] - _this.startPosition[1];
        _this.isScrolling = Math.abs(diffScrollDir) > Math.abs(diffMainDir);
      }

      if (_this.isScrolling) {
        _this.setState({
          index: -1
        });

        return;
      }

      const diffPosition = _this.getDiffPosition(position[0]);

      const newValue = _this.getValueFromPosition(diffPosition);

      _this.move(newValue);
    };

    _this.onKeyDown = e => {
      if (e.ctrlKey || e.shiftKey || e.altKey || e.metaKey) {
        return;
      } // Prevent controlled updates from happening while a key is pressed


      _this.setState({
        pending: true
      });

      switch (e.key) {
        case 'ArrowLeft':
        case 'ArrowDown':
        case 'Left':
        case 'Down':
          e.preventDefault();

          _this.moveDownByStep();

          break;

        case 'ArrowRight':
        case 'ArrowUp':
        case 'Right':
        case 'Up':
          e.preventDefault();

          _this.moveUpByStep();

          break;

        case 'Home':
          e.preventDefault();

          _this.move(_this.props.min);

          break;

        case 'End':
          e.preventDefault();

          _this.move(_this.props.max);

          break;

        case 'PageDown':
          e.preventDefault();

          _this.moveDownByStep(_this.props.pageFn(_this.props.step));

          break;

        case 'PageUp':
          e.preventDefault();

          _this.moveUpByStep(_this.props.pageFn(_this.props.step));

          break;
      }
    };

    _this.onSliderMouseDown = e => {
      // do nothing if disabled or right click
      if (_this.props.disabled || e.button === 2) {
        return;
      } // Prevent controlled updates from happening while mouse is moving


      _this.setState({
        pending: true
      });

      if (!_this.props.snapDragDisabled) {
        const position = _this.getMousePosition(e);

        _this.forceValueFromPosition(position[0], i => {
          _this.start(i, position[0]);

          addHandlers(_this.getMouseEventMap());
        });
      }

      pauseEvent(e);
    };

    _this.onSliderClick = e => {
      if (_this.props.disabled) {
        return;
      }

      if (_this.props.onSliderClick && !_this.hasMoved) {
        const position = _this.getMousePosition(e);

        const valueAtPos = trimAlignValue(_this.calcValue(_this.calcOffsetFromPosition(position[0])), _this.props);

        _this.props.onSliderClick(valueAtPos);
      }
    };

    _this.createOnKeyDown = i => e => {
      if (_this.props.disabled) {
        return;
      }

      _this.start(i);

      addHandlers(_this.getKeyDownEventMap());
      pauseEvent(e);
    };

    _this.createOnMouseDown = i => e => {
      // do nothing if disabled or right click
      if (_this.props.disabled || e.button === 2) {
        return;
      } // Prevent controlled updates from happending while mouse is moving


      _this.setState({
        pending: true
      });

      const position = _this.getMousePosition(e);

      _this.start(i, position[0]);

      addHandlers(_this.getMouseEventMap());
      pauseEvent(e);
    };

    _this.createOnTouchStart = i => e => {
      if (_this.props.disabled || e.touches.length > 1) {
        return;
      } // Prevent controlled updates from happending while touch is moving


      _this.setState({
        pending: true
      });

      const position = _this.getTouchPosition(e);

      _this.startPosition = position; // don't know yet if the user is trying to scroll

      _this.isScrolling = undefined;

      _this.start(i, position[0]);

      addHandlers(_this.getTouchEventMap());
      stopPropagation(e);
    };

    _this.handleResize = () => {
      // setTimeout of 0 gives element enough time to have assumed its new size if
      // it is being resized
      const resizeTimeout = window.setTimeout(() => {
        // drop this timeout from pendingResizeTimeouts to reduce memory usage
        _this.pendingResizeTimeouts.shift();

        _this.resize();
      }, 0);

      _this.pendingResizeTimeouts.push(resizeTimeout);
    };

    _this.renderThumb = (style, i) => {
      const className = _this.props.thumbClassName + " " + _this.props.thumbClassName + "-" + i + " " + (_this.state.index === i ? _this.props.thumbActiveClassName : '');
      const props = {
        'ref': r => {
          _this["thumb" + i] = r;
        },
        'key': _this.props.thumbClassName + "-" + i,
        className,
        style,
        'onMouseDown': _this.createOnMouseDown(i),
        'onTouchStart': _this.createOnTouchStart(i),
        'onFocus': _this.createOnKeyDown(i),
        'tabIndex': 0,
        'role': 'slider',
        'aria-orientation': _this.props.orientation,
        'aria-valuenow': _this.state.value[i],
        'aria-valuemin': _this.props.min,
        'aria-valuemax': _this.props.max,
        'aria-label': Array.isArray(_this.props.ariaLabel) ? _this.props.ariaLabel[i] : _this.props.ariaLabel,
        'aria-labelledby': Array.isArray(_this.props.ariaLabelledby) ? _this.props.ariaLabelledby[i] : _this.props.ariaLabelledby
      };
      const state = {
        index: i,
        value: prepareOutValue(_this.state.value),
        valueNow: _this.state.value[i]
      };

      if (_this.props.ariaValuetext) {
        props['aria-valuetext'] = typeof _this.props.ariaValuetext === 'string' ? _this.props.ariaValuetext : _this.props.ariaValuetext(state);
      }

      return _this.props.renderThumb(props, state);
    };

    _this.renderTrack = (i, offsetFrom, offsetTo) => {
      const props = {
        key: _this.props.trackClassName + "-" + i,
        className: _this.props.trackClassName + " " + _this.props.trackClassName + "-" + i,
        style: _this.buildTrackStyle(offsetFrom, _this.state.upperBound - offsetTo)
      };
      const state = {
        index: i,
        value: prepareOutValue(_this.state.value)
      };
      return _this.props.renderTrack(props, state);
    };

    let value = sanitizeInValue(_props.value);

    if (!value.length) {
      value = sanitizeInValue(_props.defaultValue);
    } // array for storing resize timeouts ids


    _this.pendingResizeTimeouts = [];
    const zIndices = [];

    for (let i = 0; i < value.length; i += 1) {
      value[i] = trimAlignValue(value[i], _props);
      zIndices.push(i);
    }

    _this.resizeObserver = null;
    _this.resizeElementRef = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_2__.createRef();
    _this.state = {
      index: -1,
      upperBound: 0,
      sliderLength: 0,
      value,
      zIndices
    };
    return _this;
  }

  var _proto = ReactSlider.prototype;

  _proto.componentDidMount = function componentDidMount() {
    if (typeof window !== 'undefined') {
      this.resizeObserver = new ResizeObserver(this.handleResize);
      this.resizeObserver.observe(this.resizeElementRef.current);
      this.resize();
    }
  } // Keep the internal `value` consistent with an outside `value` if present.
  // This basically allows the slider to be a controlled component.
  ;

  ReactSlider.getDerivedStateFromProps = function getDerivedStateFromProps(props, state) {
    const value = sanitizeInValue(props.value);

    if (!value.length) {
      return null;
    } // Do not allow controlled upates to happen while we have pending updates


    if (state.pending) {
      return null;
    }

    return {
      value: value.map(item => trimAlignValue(item, props))
    };
  };

  _proto.componentDidUpdate = function componentDidUpdate() {
    // If an upperBound has not yet been determined (due to the component being hidden
    // during the mount event, or during the last resize), then calculate it now
    if (this.state.upperBound === 0) {
      this.resize();
    }
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.clearPendingResizeTimeouts();

    if (this.resizeObserver) {
      this.resizeObserver.disconnect();
    }
  };

  _proto.onEnd = function onEnd(eventMap) {
    if (eventMap) {
      removeHandlers(eventMap);
    }

    if (this.hasMoved) {
      this.fireChangeEvent('onAfterChange');
    } // Allow controlled updates to continue


    this.setState({
      pending: false
    });
    this.hasMoved = false;
  };

  _proto.getValue = function getValue() {
    return prepareOutValue(this.state.value);
  };

  _proto.getClosestIndex = function getClosestIndex(pixelOffset) {
    let minDist = Number.MAX_VALUE;
    let closestIndex = -1;
    const {
      value
    } = this.state;
    const l = value.length;

    for (let i = 0; i < l; i += 1) {
      const offset = this.calcOffset(value[i]);
      const dist = Math.abs(pixelOffset - offset);

      if (dist < minDist) {
        minDist = dist;
        closestIndex = i;
      }
    }

    return closestIndex;
  };

  _proto.getMousePosition = function getMousePosition(e) {
    return [e["page" + this.axisKey()], e["page" + this.orthogonalAxisKey()]];
  };

  _proto.getTouchPosition = function getTouchPosition(e) {
    const touch = e.touches[0];
    return [touch["page" + this.axisKey()], touch["page" + this.orthogonalAxisKey()]];
  };

  _proto.getKeyDownEventMap = function getKeyDownEventMap() {
    return {
      keydown: this.onKeyDown,
      keyup: this.onKeyUp,
      focusout: this.onBlur
    };
  };

  _proto.getMouseEventMap = function getMouseEventMap() {
    return {
      mousemove: this.onMouseMove,
      mouseup: this.onMouseUp
    };
  };

  _proto.getTouchEventMap = function getTouchEventMap() {
    return {
      touchmove: this.onTouchMove,
      touchend: this.onTouchEnd
    };
  };

  _proto.getValueFromPosition = function getValueFromPosition(position) {
    const diffValue = position / (this.state.sliderLength - this.state.thumbSize) * (this.props.max - this.props.min);
    return trimAlignValue(this.state.startValue + diffValue, this.props);
  };

  _proto.getDiffPosition = function getDiffPosition(position) {
    let diffPosition = position - this.state.startPosition;

    if (this.props.invert) {
      diffPosition *= -1;
    }

    return diffPosition;
  } // create the `keydown` handler for the i-th thumb
  ;

  _proto.resize = function resize() {
    const {
      slider,
      thumb0: thumb
    } = this;

    if (!slider || !thumb) {
      return;
    }

    const sizeKey = this.sizeKey(); // For the slider size, we want to use the client width/height, excluding any borders

    const sliderRect = slider.getBoundingClientRect();
    const sliderSize = slider[sizeKey];
    const sliderMax = sliderRect[this.posMaxKey()];
    const sliderMin = sliderRect[this.posMinKey()]; // For the thumb size, we want to use the outer width/height, including any borders

    const thumbRect = thumb.getBoundingClientRect();
    const thumbSize = thumbRect[sizeKey.replace('client', '').toLowerCase()];
    const upperBound = sliderSize - thumbSize;
    const sliderLength = Math.abs(sliderMax - sliderMin);

    if (this.state.upperBound !== upperBound || this.state.sliderLength !== sliderLength || this.state.thumbSize !== thumbSize) {
      this.setState({
        upperBound,
        sliderLength,
        thumbSize
      });
    }
  } // calculates the offset of a thumb in pixels based on its value.
  ;

  _proto.calcOffset = function calcOffset(value) {
    const range = this.props.max - this.props.min;

    if (range === 0) {
      return 0;
    }

    const ratio = (value - this.props.min) / range;
    return ratio * this.state.upperBound;
  } // calculates the value corresponding to a given pixel offset, i.e. the inverse of `calcOffset`.
  ;

  _proto.calcValue = function calcValue(offset) {
    const ratio = offset / this.state.upperBound;
    return ratio * (this.props.max - this.props.min) + this.props.min;
  };

  _proto.calcOffsetFromPosition = function calcOffsetFromPosition(position) {
    const {
      slider
    } = this;
    const sliderRect = slider.getBoundingClientRect();
    const sliderMax = sliderRect[this.posMaxKey()];
    const sliderMin = sliderRect[this.posMinKey()]; // The `position` value passed in is the mouse position based on the window height.
    // The slider bounding rect is based on the viewport, so we must add the window scroll
    // offset to normalize the values.

    const windowOffset = window["page" + this.axisKey() + "Offset"];
    const sliderStart = windowOffset + (this.props.invert ? sliderMax : sliderMin);
    let pixelOffset = position - sliderStart;

    if (this.props.invert) {
      pixelOffset = this.state.sliderLength - pixelOffset;
    }

    pixelOffset -= this.state.thumbSize / 2;
    return pixelOffset;
  } // Snaps the nearest thumb to the value corresponding to `position`
  // and calls `callback` with that thumb's index.
  ;

  _proto.forceValueFromPosition = function forceValueFromPosition(position, callback) {
    const pixelOffset = this.calcOffsetFromPosition(position);
    const closestIndex = this.getClosestIndex(pixelOffset);
    const nextValue = trimAlignValue(this.calcValue(pixelOffset), this.props); // Clone this.state.value since we'll modify it temporarily
    // eslint-disable-next-line zillow/react/no-access-state-in-setstate

    const value = this.state.value.slice();
    value[closestIndex] = nextValue; // Prevents the slider from shrinking below `props.minDistance`

    for (let i = 0; i < value.length - 1; i += 1) {
      if (value[i + 1] - value[i] < this.props.minDistance) {
        return;
      }
    }

    this.fireChangeEvent('onBeforeChange');
    this.hasMoved = true;
    this.setState({
      value
    }, () => {
      callback(closestIndex);
      this.fireChangeEvent('onChange');
    });
  } // clear all pending timeouts to avoid error messages after unmounting
  ;

  _proto.clearPendingResizeTimeouts = function clearPendingResizeTimeouts() {
    do {
      const nextTimeout = this.pendingResizeTimeouts.shift();
      clearTimeout(nextTimeout);
    } while (this.pendingResizeTimeouts.length);
  };

  _proto.start = function start(i, position) {
    const thumbRef = this["thumb" + i];

    if (thumbRef) {
      thumbRef.focus();
    }

    const {
      zIndices
    } = this.state; // remove wherever the element is

    zIndices.splice(zIndices.indexOf(i), 1); // add to end

    zIndices.push(i);
    this.setState(prevState => ({
      startValue: prevState.value[i],
      startPosition: position !== undefined ? position : prevState.startPosition,
      index: i,
      zIndices
    }));
  };

  _proto.moveUpByStep = function moveUpByStep(step) {
    if (step === void 0) {
      step = this.props.step;
    }

    const oldValue = this.state.value[this.state.index];
    const newValue = trimAlignValue(oldValue + step, this.props);
    this.move(Math.min(newValue, this.props.max));
  };

  _proto.moveDownByStep = function moveDownByStep(step) {
    if (step === void 0) {
      step = this.props.step;
    }

    const oldValue = this.state.value[this.state.index];
    const newValue = trimAlignValue(oldValue - step, this.props);
    this.move(Math.max(newValue, this.props.min));
  };

  _proto.move = function move(newValue) {
    const {
      index,
      value
    } = this.state;
    const {
      length
    } = value; // Short circuit if the value is not changing

    const oldValue = value[index];

    if (newValue === oldValue) {
      return;
    } // Trigger only before the first movement


    if (!this.hasMoved) {
      this.fireChangeEvent('onBeforeChange');
    }

    this.hasMoved = true; // if "pearling" (= thumbs pushing each other) is disabled,
    // prevent the thumb from getting closer than `minDistance` to the previous or next thumb.

    const {
      pearling,
      max,
      min,
      minDistance
    } = this.props;

    if (!pearling) {
      if (index > 0) {
        const valueBefore = value[index - 1];

        if (newValue < valueBefore + minDistance) {
          // eslint-disable-next-line no-param-reassign
          newValue = valueBefore + minDistance;
        }
      }

      if (index < length - 1) {
        const valueAfter = value[index + 1];

        if (newValue > valueAfter - minDistance) {
          // eslint-disable-next-line no-param-reassign
          newValue = valueAfter - minDistance;
        }
      }
    }

    value[index] = newValue; // if "pearling" is enabled, let the current thumb push the pre- and succeeding thumbs.

    if (pearling && length > 1) {
      if (newValue > oldValue) {
        this.pushSucceeding(value, minDistance, index);
        trimSucceeding(length, value, minDistance, max);
      } else if (newValue < oldValue) {
        this.pushPreceding(value, minDistance, index);
        trimPreceding(length, value, minDistance, min);
      }
    } // Normally you would use `shouldComponentUpdate`,
    // but since the slider is a low-level component,
    // the extra complexity might be worth the extra performance.


    this.setState({
      value
    }, this.fireChangeEvent.bind(this, 'onChange'));
  };

  _proto.pushSucceeding = function pushSucceeding(value, minDistance, index) {
    let i;
    let padding;

    for (i = index, padding = value[i] + minDistance; value[i + 1] !== null && padding > value[i + 1]; i += 1, padding = value[i] + minDistance) {
      // eslint-disable-next-line no-param-reassign
      value[i + 1] = alignValue(padding, this.props);
    }
  };

  _proto.pushPreceding = function pushPreceding(value, minDistance, index) {
    for (let i = index, padding = value[i] - minDistance; value[i - 1] !== null && padding < value[i - 1]; i -= 1, padding = value[i] - minDistance) {
      // eslint-disable-next-line no-param-reassign
      value[i - 1] = alignValue(padding, this.props);
    }
  };

  _proto.axisKey = function axisKey() {
    if (this.props.orientation === 'vertical') {
      return 'Y';
    } // Defaults to 'horizontal';


    return 'X';
  };

  _proto.orthogonalAxisKey = function orthogonalAxisKey() {
    if (this.props.orientation === 'vertical') {
      return 'X';
    } // Defaults to 'horizontal'


    return 'Y';
  };

  _proto.posMinKey = function posMinKey() {
    if (this.props.orientation === 'vertical') {
      return this.props.invert ? 'bottom' : 'top';
    } // Defaults to 'horizontal'


    return this.props.invert ? 'right' : 'left';
  };

  _proto.posMaxKey = function posMaxKey() {
    if (this.props.orientation === 'vertical') {
      return this.props.invert ? 'top' : 'bottom';
    } // Defaults to 'horizontal'


    return this.props.invert ? 'left' : 'right';
  };

  _proto.sizeKey = function sizeKey() {
    if (this.props.orientation === 'vertical') {
      return 'clientHeight';
    } // Defaults to 'horizontal'


    return 'clientWidth';
  };

  _proto.fireChangeEvent = function fireChangeEvent(event) {
    if (this.props[event]) {
      this.props[event](prepareOutValue(this.state.value), this.state.index);
    }
  };

  _proto.buildThumbStyle = function buildThumbStyle(offset, i) {
    const style = {
      position: 'absolute',
      touchAction: 'none',
      willChange: this.state.index >= 0 ? this.posMinKey() : undefined,
      zIndex: this.state.zIndices.indexOf(i) + 1
    };
    style[this.posMinKey()] = offset + "px";
    return style;
  };

  _proto.buildTrackStyle = function buildTrackStyle(min, max) {
    const obj = {
      position: 'absolute',
      willChange: this.state.index >= 0 ? this.posMinKey() + "," + this.posMaxKey() : undefined
    };
    obj[this.posMinKey()] = min;
    obj[this.posMaxKey()] = max;
    return obj;
  };

  _proto.buildMarkStyle = function buildMarkStyle(offset) {
    var _ref;

    return _ref = {
      position: 'absolute'
    }, _ref[this.posMinKey()] = offset, _ref;
  };

  _proto.renderThumbs = function renderThumbs(offset) {
    const {
      length
    } = offset;
    const styles = [];

    for (let i = 0; i < length; i += 1) {
      styles[i] = this.buildThumbStyle(offset[i], i);
    }

    const res = [];

    for (let i = 0; i < length; i += 1) {
      res[i] = this.renderThumb(styles[i], i);
    }

    return res;
  };

  _proto.renderTracks = function renderTracks(offset) {
    const tracks = [];
    const lastIndex = offset.length - 1;
    tracks.push(this.renderTrack(0, 0, offset[0]));

    for (let i = 0; i < lastIndex; i += 1) {
      tracks.push(this.renderTrack(i + 1, offset[i], offset[i + 1]));
    }

    tracks.push(this.renderTrack(lastIndex + 1, offset[lastIndex], this.state.upperBound));
    return tracks;
  };

  _proto.renderMarks = function renderMarks() {
    let {
      marks
    } = this.props;
    const range = this.props.max - this.props.min + 1;

    if (typeof marks === 'boolean') {
      marks = Array.from({
        length: range
      }).map((_, key) => key);
    } else if (typeof marks === 'number') {
      marks = Array.from({
        length: range
      }).map((_, key) => key).filter(key => key % marks === 0);
    }

    return marks.map(parseFloat).sort((a, b) => a - b).map(mark => {
      const offset = this.calcOffset(mark);
      const props = {
        key: mark,
        className: this.props.markClassName,
        style: this.buildMarkStyle(offset)
      };
      return this.props.renderMark(props);
    });
  };

  _proto.render = function render() {
    const offset = [];
    const {
      value
    } = this.state;
    const l = value.length;

    for (let i = 0; i < l; i += 1) {
      offset[i] = this.calcOffset(value[i], i);
    }

    const tracks = this.props.withTracks ? this.renderTracks(offset) : null;
    const thumbs = this.renderThumbs(offset);
    const marks = this.props.marks ? this.renderMarks() : null;
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_2__.createElement('div', {
      ref: r => {
        this.slider = r;
        this.resizeElementRef.current = r;
      },
      style: {
        position: 'relative'
      },
      className: this.props.className + (this.props.disabled ? ' disabled' : ''),
      onMouseDown: this.onSliderMouseDown,
      onClick: this.onSliderClick
    }, tracks, thumbs, marks);
  };

  return ReactSlider;
}(react__WEBPACK_IMPORTED_MODULE_2__.Component);

ReactSlider.displayName = 'ReactSlider';
ReactSlider.defaultProps = {
  min: 0,
  max: 100,
  step: 1,
  pageFn: step => step * 10,
  minDistance: 0,
  defaultValue: 0,
  orientation: 'horizontal',
  className: 'slider',
  thumbClassName: 'thumb',
  thumbActiveClassName: 'active',
  trackClassName: 'track',
  markClassName: 'mark',
  withTracks: true,
  pearling: false,
  disabled: false,
  snapDragDisabled: false,
  invert: false,
  marks: [],
  renderThumb: props => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_2__.createElement("div", (0,_babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, props, {
    __self: ReactSlider,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 353,
      columnNumber: 31
    }
  })),
  renderTrack: props => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_2__.createElement("div", (0,_babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, props, {
    __self: ReactSlider,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 354,
      columnNumber: 31
    }
  })),
  renderMark: props => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_2__.createElement("span", (0,_babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, props, {
    __self: ReactSlider,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 355,
      columnNumber: 30
    }
  }))
};
ReactSlider.propTypes =  true ? {
  /**
   * The minimum value of the slider.
   */
  min: prop_types__WEBPACK_IMPORTED_MODULE_3__.number,

  /**
   * The maximum value of the slider.
   */
  max: prop_types__WEBPACK_IMPORTED_MODULE_3__.number,

  /**
   * Value to be added or subtracted on each step the slider makes.
   * Must be greater than zero.
   * `max - min` should be evenly divisible by the step value.
   */
  step: prop_types__WEBPACK_IMPORTED_MODULE_3__.number,

  /**
   * The result of the function is the value to be added or subtracted
   * when the `Page Up` or `Page Down` keys are pressed.
   *
   * The current `step` value will be passed as the only argument.
   * By default, paging will modify `step` by a factor of 10.
   */
  pageFn: prop_types__WEBPACK_IMPORTED_MODULE_3__.func,

  /**
   * The minimal distance between any pair of thumbs.
   * Must be positive, but zero means they can sit on top of each other.
   */
  minDistance: prop_types__WEBPACK_IMPORTED_MODULE_3__.number,

  /**
   * Determines the initial positions of the thumbs and the number of thumbs.
   *
   * If a number is passed a slider with one thumb will be rendered.
   * If an array is passed each value will determine the position of one thumb.
   * The values in the array must be sorted.
   */
  defaultValue: prop_types__WEBPACK_IMPORTED_MODULE_3__.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_3__.number, prop_types__WEBPACK_IMPORTED_MODULE_3__.arrayOf(prop_types__WEBPACK_IMPORTED_MODULE_3__.number)]),

  /**
   * Like `defaultValue` but for
   * [controlled components](http://facebook.github.io/react/docs/forms.html#controlled-components).
   */
  // eslint-disable-next-line zillow/react/require-default-props
  value: prop_types__WEBPACK_IMPORTED_MODULE_3__.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_3__.number, prop_types__WEBPACK_IMPORTED_MODULE_3__.arrayOf(prop_types__WEBPACK_IMPORTED_MODULE_3__.number)]),

  /**
   * Determines whether the slider moves horizontally (from left to right)
   * or vertically (from top to bottom).
   */
  orientation: prop_types__WEBPACK_IMPORTED_MODULE_3__.oneOf(['horizontal', 'vertical']),

  /**
   * The css class set on the slider node.
   */
  className: prop_types__WEBPACK_IMPORTED_MODULE_3__.string,

  /**
   * The css class set on each thumb node.
   *
   * In addition each thumb will receive a numbered css class of the form
   * `${thumbClassName}-${i}`, e.g. `thumb-0`, `thumb-1`, ...
   */
  thumbClassName: prop_types__WEBPACK_IMPORTED_MODULE_3__.string,

  /**
   * The css class set on the thumb that is currently being moved.
   */
  thumbActiveClassName: prop_types__WEBPACK_IMPORTED_MODULE_3__.string,

  /**
   * If `true` tracks between the thumbs will be rendered.
   */
  withTracks: prop_types__WEBPACK_IMPORTED_MODULE_3__.bool,

  /**
   * The css class set on the tracks between the thumbs.
   * In addition track fragment will receive a numbered css class of the form
   * `${trackClassName}-${i}`, e.g. `track-0`, `track-1`, ...
   */
  trackClassName: prop_types__WEBPACK_IMPORTED_MODULE_3__.string,

  /**
   * If `true` the active thumb will push other thumbs
   * within the constraints of `min`, `max`, `step` and `minDistance`.
   */
  pearling: prop_types__WEBPACK_IMPORTED_MODULE_3__.bool,

  /**
   * If `true` the thumbs can't be moved.
   */
  disabled: prop_types__WEBPACK_IMPORTED_MODULE_3__.bool,

  /**
   * Disables thumb move when clicking the slider track
   */
  snapDragDisabled: prop_types__WEBPACK_IMPORTED_MODULE_3__.bool,

  /**
   * Inverts the slider.
   */
  invert: prop_types__WEBPACK_IMPORTED_MODULE_3__.bool,

  /**
   * Shows passed marks on the track, if true it shows all the marks,
   * if an array of numbers it shows just the passed marks, if a number is passed
   * it shows just the marks in that steps: like passing 3 shows the marks 3, 6, 9
   */
  marks: prop_types__WEBPACK_IMPORTED_MODULE_3__.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_3__.arrayOf(prop_types__WEBPACK_IMPORTED_MODULE_3__.number), prop_types__WEBPACK_IMPORTED_MODULE_3__.bool, prop_types__WEBPACK_IMPORTED_MODULE_3__.number]),

  /**
   * The css class set on the marks.
   */
  markClassName: prop_types__WEBPACK_IMPORTED_MODULE_3__.string,

  /**
   * Callback called before starting to move a thumb. The callback will only be called if the
   * action will result in a change. The function will be called with two arguments, the first
   * being the initial value(s) the second being thumb index.
   */
  // eslint-disable-next-line max-len
  // eslint-disable-next-line zillow/react/require-default-props, zillow/react/no-unused-prop-types
  onBeforeChange: prop_types__WEBPACK_IMPORTED_MODULE_3__.func,

  /**
   * Callback called on every value change.
   * The function will be called with two arguments, the first being the new value(s)
   * the second being thumb index.
   */
  // eslint-disable-next-line max-len
  // eslint-disable-next-line zillow/react/require-default-props, zillow/react/no-unused-prop-types
  onChange: prop_types__WEBPACK_IMPORTED_MODULE_3__.func,

  /**
   * Callback called only after moving a thumb has ended. The callback will only be called if
   * the action resulted in a change. The function will be called with two arguments, the
   * first being the result value(s) the second being thumb index.
   */
  // eslint-disable-next-line max-len
  // eslint-disable-next-line zillow/react/require-default-props, zillow/react/no-unused-prop-types
  onAfterChange: prop_types__WEBPACK_IMPORTED_MODULE_3__.func,

  /**
   * Callback called when the the slider is clicked (thumb or tracks).
   * Receives the value at the clicked position as argument.
   */
  // eslint-disable-next-line zillow/react/require-default-props
  onSliderClick: prop_types__WEBPACK_IMPORTED_MODULE_3__.func,

  /**
   * aria-label for screen-readers to apply to the thumbs.
   * Use an array for more than one thumb.
   * The length of the array must match the number of thumbs in the value array.
   */
  // eslint-disable-next-line zillow/react/require-default-props
  ariaLabel: prop_types__WEBPACK_IMPORTED_MODULE_3__.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_3__.string, prop_types__WEBPACK_IMPORTED_MODULE_3__.arrayOf(prop_types__WEBPACK_IMPORTED_MODULE_3__.string)]),

  /**
   * aria-labelledby for screen-readers to apply to the thumbs.
   * Used when slider rendered with separate label.
   * Use an array for more than one thumb.
   * The length of the array must match the number of thumbs in the value array.
   */
  // eslint-disable-next-line zillow/react/require-default-props
  ariaLabelledby: prop_types__WEBPACK_IMPORTED_MODULE_3__.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_3__.string, prop_types__WEBPACK_IMPORTED_MODULE_3__.arrayOf(prop_types__WEBPACK_IMPORTED_MODULE_3__.string)]),

  /**
   * aria-valuetext for screen-readers.
   * Can be a static string, or a function that returns a string.
   * The function will be passed a single argument,
   * an object with the following properties:
   *
   *     state => `Value: ${state.value}`
   *
   * - `state.index` {`number`} the index of the thumb
   * - `state.value` {`number` | `array`} the current value state
   * - `state.valueNow` {`number`} the value of the thumb (i.e. aria-valuenow)
   */
  // eslint-disable-next-line zillow/react/require-default-props
  ariaValuetext: prop_types__WEBPACK_IMPORTED_MODULE_3__.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_3__.string, prop_types__WEBPACK_IMPORTED_MODULE_3__.func]),

  /**
   * Provide a custom render function for the track node.
   * The render function will be passed two arguments,
   * an object with props that should be added to your handle node,
   * and an object with track and slider state:
   *
   *     (props, state) => <div {...props} />
   *
   * - `props` {`object`} props to be spread into your track node
   * - `state.index` {`number`} the index of the track
   * - `state.value` {`number` | `array`} the current value state
   */
  renderTrack: prop_types__WEBPACK_IMPORTED_MODULE_3__.func,

  /**
   * Provide a custom render function for dynamic thumb content.
   * The render function will be passed two arguments,
   * an object with props that should be added to your thumb node,
   * and an object with thumb and slider state:
   *
   *     (props, state) => <div {...props} />
   *
   * - `props` {`object`} props to be spread into your thumb node
   * - `state.index` {`number`} the index of the thumb
   * - `state.value` {`number` | `array`} the current value state
   * - `state.valueNow` {`number`} the value of the thumb (i.e. aria-valuenow)
   */
  // eslint-disable-next-line zillow/react/require-default-props
  renderThumb: prop_types__WEBPACK_IMPORTED_MODULE_3__.func,

  /**
   * Provide a custom render function for the mark node.
   * The render function will be passed one argument,
   * an object with props that should be added to your handle node
   *
   *     (props) => <span {...props} />
   *
   * - `props` {`object`} props to be spread into your track node
   */
  renderMark: prop_types__WEBPACK_IMPORTED_MODULE_3__.func
} : 0;
var ReactSlider$1 = ReactSlider;


//# sourceMappingURL=ReactSlider.mjs.map


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfcmVhY3Qtc2xpZGVyX2Rpc3RfZXNfZGV2X2NvbXBvbmVudHNfUmVhY3RTbGlkZXJfUmVhY3RTbGlkZXJfbWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXNEO0FBQ1k7QUFDeEM7QUFDUzs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsRUFBRSxnRkFBYzs7QUFFaEI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBLE9BQU87O0FBRVA7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7QUFDQSxPQUFPOztBQUVQOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0EsT0FBTzs7QUFFUDs7QUFFQSxzQ0FBc0M7O0FBRXRDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFpQixDQUFDLDhDQUFnQjs7QUFFM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFlBQVk7QUFDeEM7QUFDQSxzQkFBc0IsVUFBVTtBQUNoQyxzQkFBc0Isb0JBQW9CO0FBQzFDLHlCQUF5QixVQUFVO0FBQ25DO0FBQ0E7QUFDQSxpQkFBaUIsaURBQW1CLEVBQUUsOENBQWdCLEVBQUUsNENBQWM7O0FBRXRFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxVQUFVO0FBQzNDO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUIsc0JBQXNCLFVBQVU7QUFDaEMsc0JBQXNCLG9CQUFvQjtBQUMxQztBQUNBLGVBQWUsNENBQWM7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxVQUFVO0FBQzNDO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUIsc0JBQXNCLFVBQVU7QUFDaEMsc0JBQXNCLG9CQUFvQjtBQUMxQyx5QkFBeUIsVUFBVTtBQUNuQztBQUNBO0FBQ0EsZUFBZSw0Q0FBYzs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixVQUFVO0FBQ3JDO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQSxjQUFjLDRDQUFjO0FBQzVCLEVBQUUsRUFBRSxDQUFFO0FBQ047O0FBRW9DO0FBQ3BDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2F2aW5ncy13aWRnZXQvLi9ub2RlX21vZHVsZXMvcmVhY3Qtc2xpZGVyL2Rpc3QvZXMvZGV2L2NvbXBvbmVudHMvUmVhY3RTbGlkZXIvUmVhY3RTbGlkZXIubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfZXh0ZW5kcyBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2V4dGVuZHMnO1xuaW1wb3J0IF9pbmhlcml0c0xvb3NlIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHNMb29zZSc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcblxudmFyIF9qc3hGaWxlTmFtZSA9IFwiL1VzZXJzL2tyaXNlL2dpdGh1Yi9yZWFjdC1zbGlkZXIvc3JjL2NvbXBvbmVudHMvUmVhY3RTbGlkZXIvUmVhY3RTbGlkZXIuanN4XCI7XG4vKipcbiAqIFRvIHByZXZlbnQgdGV4dCBzZWxlY3Rpb24gd2hpbGUgZHJhZ2dpbmcuXG4gKiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzU0Mjk4MjcvaG93LWNhbi1pLXByZXZlbnQtdGV4dC1lbGVtZW50LXNlbGVjdGlvbi13aXRoLWN1cnNvci1kcmFnXG4gKi9cblxuZnVuY3Rpb24gcGF1c2VFdmVudChlKSB7XG4gIGlmIChlICYmIGUuc3RvcFByb3BhZ2F0aW9uKSB7XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgfVxuXG4gIGlmIChlICYmIGUucHJldmVudERlZmF1bHQpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHN0b3BQcm9wYWdhdGlvbihlKSB7XG4gIGlmIChlLnN0b3BQcm9wYWdhdGlvbikge1xuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2FuaXRpemVJblZhbHVlKHgpIHtcbiAgaWYgKHggPT0gbnVsbCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIHJldHVybiBBcnJheS5pc0FycmF5KHgpID8geC5zbGljZSgpIDogW3hdO1xufVxuXG5mdW5jdGlvbiBwcmVwYXJlT3V0VmFsdWUoeCkge1xuICByZXR1cm4geCAhPT0gbnVsbCAmJiB4Lmxlbmd0aCA9PT0gMSA/IHhbMF0gOiB4LnNsaWNlKCk7XG59XG5cbmZ1bmN0aW9uIHRyaW1TdWNjZWVkaW5nKGxlbmd0aCwgbmV4dFZhbHVlLCBtaW5EaXN0YW5jZSwgbWF4KSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICBjb25zdCBwYWRkaW5nID0gbWF4IC0gaSAqIG1pbkRpc3RhbmNlO1xuXG4gICAgaWYgKG5leHRWYWx1ZVtsZW5ndGggLSAxIC0gaV0gPiBwYWRkaW5nKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgIG5leHRWYWx1ZVtsZW5ndGggLSAxIC0gaV0gPSBwYWRkaW5nO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB0cmltUHJlY2VkaW5nKGxlbmd0aCwgbmV4dFZhbHVlLCBtaW5EaXN0YW5jZSwgbWluKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICBjb25zdCBwYWRkaW5nID0gbWluICsgaSAqIG1pbkRpc3RhbmNlO1xuXG4gICAgaWYgKG5leHRWYWx1ZVtpXSA8IHBhZGRpbmcpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgbmV4dFZhbHVlW2ldID0gcGFkZGluZztcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkSGFuZGxlcnMoZXZlbnRNYXApIHtcbiAgT2JqZWN0LmtleXMoZXZlbnRNYXApLmZvckVhY2goa2V5ID0+IHtcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihrZXksIGV2ZW50TWFwW2tleV0sIGZhbHNlKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiByZW1vdmVIYW5kbGVycyhldmVudE1hcCkge1xuICBPYmplY3Qua2V5cyhldmVudE1hcCkuZm9yRWFjaChrZXkgPT4ge1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGtleSwgZXZlbnRNYXBba2V5XSwgZmFsc2UpO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHRyaW1BbGlnblZhbHVlKHZhbCwgcHJvcHMpIHtcbiAgcmV0dXJuIGFsaWduVmFsdWUodHJpbVZhbHVlKHZhbCwgcHJvcHMpLCBwcm9wcyk7XG59XG5cbmZ1bmN0aW9uIGFsaWduVmFsdWUodmFsLCBwcm9wcykge1xuICBjb25zdCB2YWxNb2RTdGVwID0gKHZhbCAtIHByb3BzLm1pbikgJSBwcm9wcy5zdGVwO1xuICBsZXQgYWxpZ25lZFZhbHVlID0gdmFsIC0gdmFsTW9kU3RlcDtcblxuICBpZiAoTWF0aC5hYnModmFsTW9kU3RlcCkgKiAyID49IHByb3BzLnN0ZXApIHtcbiAgICBhbGlnbmVkVmFsdWUgKz0gdmFsTW9kU3RlcCA+IDAgPyBwcm9wcy5zdGVwIDogLXByb3BzLnN0ZXA7XG4gIH1cblxuICByZXR1cm4gcGFyc2VGbG9hdChhbGlnbmVkVmFsdWUudG9GaXhlZCg1KSk7XG59XG5cbmZ1bmN0aW9uIHRyaW1WYWx1ZSh2YWwsIHByb3BzKSB7XG4gIGxldCB0cmltbWVkID0gdmFsO1xuXG4gIGlmICh0cmltbWVkIDw9IHByb3BzLm1pbikge1xuICAgIHRyaW1tZWQgPSBwcm9wcy5taW47XG4gIH1cblxuICBpZiAodHJpbW1lZCA+PSBwcm9wcy5tYXgpIHtcbiAgICB0cmltbWVkID0gcHJvcHMubWF4O1xuICB9XG5cbiAgcmV0dXJuIHRyaW1tZWQ7XG59XG5cbmxldCBSZWFjdFNsaWRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHNMb29zZShSZWFjdFNsaWRlciwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gUmVhY3RTbGlkZXIoX3Byb3BzKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX3RoaXMgPSBfUmVhY3QkQ29tcG9uZW50LmNhbGwodGhpcywgX3Byb3BzKSB8fCB0aGlzO1xuXG4gICAgX3RoaXMub25LZXlVcCA9ICgpID0+IHtcbiAgICAgIF90aGlzLm9uRW5kKCk7XG4gICAgfTtcblxuICAgIF90aGlzLm9uTW91c2VVcCA9ICgpID0+IHtcbiAgICAgIF90aGlzLm9uRW5kKF90aGlzLmdldE1vdXNlRXZlbnRNYXAoKSk7XG4gICAgfTtcblxuICAgIF90aGlzLm9uVG91Y2hFbmQgPSAoKSA9PiB7XG4gICAgICBfdGhpcy5vbkVuZChfdGhpcy5nZXRUb3VjaEV2ZW50TWFwKCkpO1xuICAgIH07XG5cbiAgICBfdGhpcy5vbkJsdXIgPSAoKSA9PiB7XG4gICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIGluZGV4OiAtMVxuICAgICAgfSwgX3RoaXMub25FbmQoX3RoaXMuZ2V0S2V5RG93bkV2ZW50TWFwKCkpKTtcbiAgICB9O1xuXG4gICAgX3RoaXMub25Nb3VzZU1vdmUgPSBlID0+IHtcbiAgICAgIC8vIFByZXZlbnQgY29udHJvbGxlZCB1cGRhdGVzIGZyb20gaGFwcGVuaW5nIHdoaWxlIG1vdXNlIGlzIG1vdmluZ1xuICAgICAgX3RoaXMuc2V0U3RhdGUoe1xuICAgICAgICBwZW5kaW5nOiB0cnVlXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcG9zaXRpb24gPSBfdGhpcy5nZXRNb3VzZVBvc2l0aW9uKGUpO1xuXG4gICAgICBjb25zdCBkaWZmUG9zaXRpb24gPSBfdGhpcy5nZXREaWZmUG9zaXRpb24ocG9zaXRpb25bMF0pO1xuXG4gICAgICBjb25zdCBuZXdWYWx1ZSA9IF90aGlzLmdldFZhbHVlRnJvbVBvc2l0aW9uKGRpZmZQb3NpdGlvbik7XG5cbiAgICAgIF90aGlzLm1vdmUobmV3VmFsdWUpO1xuICAgIH07XG5cbiAgICBfdGhpcy5vblRvdWNoTW92ZSA9IGUgPT4ge1xuICAgICAgaWYgKGUudG91Y2hlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gUHJldmVudCBjb250cm9sbGVkIHVwZGF0ZXMgZnJvbSBoYXBwZW5kaW5nIHdoaWxlIHRvdWNoIGlzIG1vdmluZ1xuXG5cbiAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgcGVuZGluZzogdHJ1ZVxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gX3RoaXMuZ2V0VG91Y2hQb3NpdGlvbihlKTtcblxuICAgICAgaWYgKHR5cGVvZiBfdGhpcy5pc1Njcm9sbGluZyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uc3QgZGlmZk1haW5EaXIgPSBwb3NpdGlvblswXSAtIF90aGlzLnN0YXJ0UG9zaXRpb25bMF07XG4gICAgICAgIGNvbnN0IGRpZmZTY3JvbGxEaXIgPSBwb3NpdGlvblsxXSAtIF90aGlzLnN0YXJ0UG9zaXRpb25bMV07XG4gICAgICAgIF90aGlzLmlzU2Nyb2xsaW5nID0gTWF0aC5hYnMoZGlmZlNjcm9sbERpcikgPiBNYXRoLmFicyhkaWZmTWFpbkRpcik7XG4gICAgICB9XG5cbiAgICAgIGlmIChfdGhpcy5pc1Njcm9sbGluZykge1xuICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgaW5kZXg6IC0xXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGlmZlBvc2l0aW9uID0gX3RoaXMuZ2V0RGlmZlBvc2l0aW9uKHBvc2l0aW9uWzBdKTtcblxuICAgICAgY29uc3QgbmV3VmFsdWUgPSBfdGhpcy5nZXRWYWx1ZUZyb21Qb3NpdGlvbihkaWZmUG9zaXRpb24pO1xuXG4gICAgICBfdGhpcy5tb3ZlKG5ld1ZhbHVlKTtcbiAgICB9O1xuXG4gICAgX3RoaXMub25LZXlEb3duID0gZSA9PiB7XG4gICAgICBpZiAoZS5jdHJsS2V5IHx8IGUuc2hpZnRLZXkgfHwgZS5hbHRLZXkgfHwgZS5tZXRhS2V5KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gUHJldmVudCBjb250cm9sbGVkIHVwZGF0ZXMgZnJvbSBoYXBwZW5pbmcgd2hpbGUgYSBrZXkgaXMgcHJlc3NlZFxuXG5cbiAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgcGVuZGluZzogdHJ1ZVxuICAgICAgfSk7XG5cbiAgICAgIHN3aXRjaCAoZS5rZXkpIHtcbiAgICAgICAgY2FzZSAnQXJyb3dMZWZ0JzpcbiAgICAgICAgY2FzZSAnQXJyb3dEb3duJzpcbiAgICAgICAgY2FzZSAnTGVmdCc6XG4gICAgICAgIGNhc2UgJ0Rvd24nOlxuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgIF90aGlzLm1vdmVEb3duQnlTdGVwKCk7XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdBcnJvd1JpZ2h0JzpcbiAgICAgICAgY2FzZSAnQXJyb3dVcCc6XG4gICAgICAgIGNhc2UgJ1JpZ2h0JzpcbiAgICAgICAgY2FzZSAnVXAnOlxuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgIF90aGlzLm1vdmVVcEJ5U3RlcCgpO1xuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnSG9tZSc6XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgX3RoaXMubW92ZShfdGhpcy5wcm9wcy5taW4pO1xuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnRW5kJzpcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICBfdGhpcy5tb3ZlKF90aGlzLnByb3BzLm1heCk7XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdQYWdlRG93bic6XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgX3RoaXMubW92ZURvd25CeVN0ZXAoX3RoaXMucHJvcHMucGFnZUZuKF90aGlzLnByb3BzLnN0ZXApKTtcblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ1BhZ2VVcCc6XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgX3RoaXMubW92ZVVwQnlTdGVwKF90aGlzLnByb3BzLnBhZ2VGbihfdGhpcy5wcm9wcy5zdGVwKSk7XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3RoaXMub25TbGlkZXJNb3VzZURvd24gPSBlID0+IHtcbiAgICAgIC8vIGRvIG5vdGhpbmcgaWYgZGlzYWJsZWQgb3IgcmlnaHQgY2xpY2tcbiAgICAgIGlmIChfdGhpcy5wcm9wcy5kaXNhYmxlZCB8fCBlLmJ1dHRvbiA9PT0gMikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIFByZXZlbnQgY29udHJvbGxlZCB1cGRhdGVzIGZyb20gaGFwcGVuaW5nIHdoaWxlIG1vdXNlIGlzIG1vdmluZ1xuXG5cbiAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgcGVuZGluZzogdHJ1ZVxuICAgICAgfSk7XG5cbiAgICAgIGlmICghX3RoaXMucHJvcHMuc25hcERyYWdEaXNhYmxlZCkge1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IF90aGlzLmdldE1vdXNlUG9zaXRpb24oZSk7XG5cbiAgICAgICAgX3RoaXMuZm9yY2VWYWx1ZUZyb21Qb3NpdGlvbihwb3NpdGlvblswXSwgaSA9PiB7XG4gICAgICAgICAgX3RoaXMuc3RhcnQoaSwgcG9zaXRpb25bMF0pO1xuXG4gICAgICAgICAgYWRkSGFuZGxlcnMoX3RoaXMuZ2V0TW91c2VFdmVudE1hcCgpKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHBhdXNlRXZlbnQoZSk7XG4gICAgfTtcblxuICAgIF90aGlzLm9uU2xpZGVyQ2xpY2sgPSBlID0+IHtcbiAgICAgIGlmIChfdGhpcy5wcm9wcy5kaXNhYmxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChfdGhpcy5wcm9wcy5vblNsaWRlckNsaWNrICYmICFfdGhpcy5oYXNNb3ZlZCkge1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IF90aGlzLmdldE1vdXNlUG9zaXRpb24oZSk7XG5cbiAgICAgICAgY29uc3QgdmFsdWVBdFBvcyA9IHRyaW1BbGlnblZhbHVlKF90aGlzLmNhbGNWYWx1ZShfdGhpcy5jYWxjT2Zmc2V0RnJvbVBvc2l0aW9uKHBvc2l0aW9uWzBdKSksIF90aGlzLnByb3BzKTtcblxuICAgICAgICBfdGhpcy5wcm9wcy5vblNsaWRlckNsaWNrKHZhbHVlQXRQb3MpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfdGhpcy5jcmVhdGVPbktleURvd24gPSBpID0+IGUgPT4ge1xuICAgICAgaWYgKF90aGlzLnByb3BzLmRpc2FibGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgX3RoaXMuc3RhcnQoaSk7XG5cbiAgICAgIGFkZEhhbmRsZXJzKF90aGlzLmdldEtleURvd25FdmVudE1hcCgpKTtcbiAgICAgIHBhdXNlRXZlbnQoZSk7XG4gICAgfTtcblxuICAgIF90aGlzLmNyZWF0ZU9uTW91c2VEb3duID0gaSA9PiBlID0+IHtcbiAgICAgIC8vIGRvIG5vdGhpbmcgaWYgZGlzYWJsZWQgb3IgcmlnaHQgY2xpY2tcbiAgICAgIGlmIChfdGhpcy5wcm9wcy5kaXNhYmxlZCB8fCBlLmJ1dHRvbiA9PT0gMikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIFByZXZlbnQgY29udHJvbGxlZCB1cGRhdGVzIGZyb20gaGFwcGVuZGluZyB3aGlsZSBtb3VzZSBpcyBtb3ZpbmdcblxuXG4gICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIHBlbmRpbmc6IHRydWVcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBwb3NpdGlvbiA9IF90aGlzLmdldE1vdXNlUG9zaXRpb24oZSk7XG5cbiAgICAgIF90aGlzLnN0YXJ0KGksIHBvc2l0aW9uWzBdKTtcblxuICAgICAgYWRkSGFuZGxlcnMoX3RoaXMuZ2V0TW91c2VFdmVudE1hcCgpKTtcbiAgICAgIHBhdXNlRXZlbnQoZSk7XG4gICAgfTtcblxuICAgIF90aGlzLmNyZWF0ZU9uVG91Y2hTdGFydCA9IGkgPT4gZSA9PiB7XG4gICAgICBpZiAoX3RoaXMucHJvcHMuZGlzYWJsZWQgfHwgZS50b3VjaGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBQcmV2ZW50IGNvbnRyb2xsZWQgdXBkYXRlcyBmcm9tIGhhcHBlbmRpbmcgd2hpbGUgdG91Y2ggaXMgbW92aW5nXG5cblxuICAgICAgX3RoaXMuc2V0U3RhdGUoe1xuICAgICAgICBwZW5kaW5nOiB0cnVlXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcG9zaXRpb24gPSBfdGhpcy5nZXRUb3VjaFBvc2l0aW9uKGUpO1xuXG4gICAgICBfdGhpcy5zdGFydFBvc2l0aW9uID0gcG9zaXRpb247IC8vIGRvbid0IGtub3cgeWV0IGlmIHRoZSB1c2VyIGlzIHRyeWluZyB0byBzY3JvbGxcblxuICAgICAgX3RoaXMuaXNTY3JvbGxpbmcgPSB1bmRlZmluZWQ7XG5cbiAgICAgIF90aGlzLnN0YXJ0KGksIHBvc2l0aW9uWzBdKTtcblxuICAgICAgYWRkSGFuZGxlcnMoX3RoaXMuZ2V0VG91Y2hFdmVudE1hcCgpKTtcbiAgICAgIHN0b3BQcm9wYWdhdGlvbihlKTtcbiAgICB9O1xuXG4gICAgX3RoaXMuaGFuZGxlUmVzaXplID0gKCkgPT4ge1xuICAgICAgLy8gc2V0VGltZW91dCBvZiAwIGdpdmVzIGVsZW1lbnQgZW5vdWdoIHRpbWUgdG8gaGF2ZSBhc3N1bWVkIGl0cyBuZXcgc2l6ZSBpZlxuICAgICAgLy8gaXQgaXMgYmVpbmcgcmVzaXplZFxuICAgICAgY29uc3QgcmVzaXplVGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgLy8gZHJvcCB0aGlzIHRpbWVvdXQgZnJvbSBwZW5kaW5nUmVzaXplVGltZW91dHMgdG8gcmVkdWNlIG1lbW9yeSB1c2FnZVxuICAgICAgICBfdGhpcy5wZW5kaW5nUmVzaXplVGltZW91dHMuc2hpZnQoKTtcblxuICAgICAgICBfdGhpcy5yZXNpemUoKTtcbiAgICAgIH0sIDApO1xuXG4gICAgICBfdGhpcy5wZW5kaW5nUmVzaXplVGltZW91dHMucHVzaChyZXNpemVUaW1lb3V0KTtcbiAgICB9O1xuXG4gICAgX3RoaXMucmVuZGVyVGh1bWIgPSAoc3R5bGUsIGkpID0+IHtcbiAgICAgIGNvbnN0IGNsYXNzTmFtZSA9IF90aGlzLnByb3BzLnRodW1iQ2xhc3NOYW1lICsgXCIgXCIgKyBfdGhpcy5wcm9wcy50aHVtYkNsYXNzTmFtZSArIFwiLVwiICsgaSArIFwiIFwiICsgKF90aGlzLnN0YXRlLmluZGV4ID09PSBpID8gX3RoaXMucHJvcHMudGh1bWJBY3RpdmVDbGFzc05hbWUgOiAnJyk7XG4gICAgICBjb25zdCBwcm9wcyA9IHtcbiAgICAgICAgJ3JlZic6IHIgPT4ge1xuICAgICAgICAgIF90aGlzW1widGh1bWJcIiArIGldID0gcjtcbiAgICAgICAgfSxcbiAgICAgICAgJ2tleSc6IF90aGlzLnByb3BzLnRodW1iQ2xhc3NOYW1lICsgXCItXCIgKyBpLFxuICAgICAgICBjbGFzc05hbWUsXG4gICAgICAgIHN0eWxlLFxuICAgICAgICAnb25Nb3VzZURvd24nOiBfdGhpcy5jcmVhdGVPbk1vdXNlRG93bihpKSxcbiAgICAgICAgJ29uVG91Y2hTdGFydCc6IF90aGlzLmNyZWF0ZU9uVG91Y2hTdGFydChpKSxcbiAgICAgICAgJ29uRm9jdXMnOiBfdGhpcy5jcmVhdGVPbktleURvd24oaSksXG4gICAgICAgICd0YWJJbmRleCc6IDAsXG4gICAgICAgICdyb2xlJzogJ3NsaWRlcicsXG4gICAgICAgICdhcmlhLW9yaWVudGF0aW9uJzogX3RoaXMucHJvcHMub3JpZW50YXRpb24sXG4gICAgICAgICdhcmlhLXZhbHVlbm93JzogX3RoaXMuc3RhdGUudmFsdWVbaV0sXG4gICAgICAgICdhcmlhLXZhbHVlbWluJzogX3RoaXMucHJvcHMubWluLFxuICAgICAgICAnYXJpYS12YWx1ZW1heCc6IF90aGlzLnByb3BzLm1heCxcbiAgICAgICAgJ2FyaWEtbGFiZWwnOiBBcnJheS5pc0FycmF5KF90aGlzLnByb3BzLmFyaWFMYWJlbCkgPyBfdGhpcy5wcm9wcy5hcmlhTGFiZWxbaV0gOiBfdGhpcy5wcm9wcy5hcmlhTGFiZWwsXG4gICAgICAgICdhcmlhLWxhYmVsbGVkYnknOiBBcnJheS5pc0FycmF5KF90aGlzLnByb3BzLmFyaWFMYWJlbGxlZGJ5KSA/IF90aGlzLnByb3BzLmFyaWFMYWJlbGxlZGJ5W2ldIDogX3RoaXMucHJvcHMuYXJpYUxhYmVsbGVkYnlcbiAgICAgIH07XG4gICAgICBjb25zdCBzdGF0ZSA9IHtcbiAgICAgICAgaW5kZXg6IGksXG4gICAgICAgIHZhbHVlOiBwcmVwYXJlT3V0VmFsdWUoX3RoaXMuc3RhdGUudmFsdWUpLFxuICAgICAgICB2YWx1ZU5vdzogX3RoaXMuc3RhdGUudmFsdWVbaV1cbiAgICAgIH07XG5cbiAgICAgIGlmIChfdGhpcy5wcm9wcy5hcmlhVmFsdWV0ZXh0KSB7XG4gICAgICAgIHByb3BzWydhcmlhLXZhbHVldGV4dCddID0gdHlwZW9mIF90aGlzLnByb3BzLmFyaWFWYWx1ZXRleHQgPT09ICdzdHJpbmcnID8gX3RoaXMucHJvcHMuYXJpYVZhbHVldGV4dCA6IF90aGlzLnByb3BzLmFyaWFWYWx1ZXRleHQoc3RhdGUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX3RoaXMucHJvcHMucmVuZGVyVGh1bWIocHJvcHMsIHN0YXRlKTtcbiAgICB9O1xuXG4gICAgX3RoaXMucmVuZGVyVHJhY2sgPSAoaSwgb2Zmc2V0RnJvbSwgb2Zmc2V0VG8pID0+IHtcbiAgICAgIGNvbnN0IHByb3BzID0ge1xuICAgICAgICBrZXk6IF90aGlzLnByb3BzLnRyYWNrQ2xhc3NOYW1lICsgXCItXCIgKyBpLFxuICAgICAgICBjbGFzc05hbWU6IF90aGlzLnByb3BzLnRyYWNrQ2xhc3NOYW1lICsgXCIgXCIgKyBfdGhpcy5wcm9wcy50cmFja0NsYXNzTmFtZSArIFwiLVwiICsgaSxcbiAgICAgICAgc3R5bGU6IF90aGlzLmJ1aWxkVHJhY2tTdHlsZShvZmZzZXRGcm9tLCBfdGhpcy5zdGF0ZS51cHBlckJvdW5kIC0gb2Zmc2V0VG8pXG4gICAgICB9O1xuICAgICAgY29uc3Qgc3RhdGUgPSB7XG4gICAgICAgIGluZGV4OiBpLFxuICAgICAgICB2YWx1ZTogcHJlcGFyZU91dFZhbHVlKF90aGlzLnN0YXRlLnZhbHVlKVxuICAgICAgfTtcbiAgICAgIHJldHVybiBfdGhpcy5wcm9wcy5yZW5kZXJUcmFjayhwcm9wcywgc3RhdGUpO1xuICAgIH07XG5cbiAgICBsZXQgdmFsdWUgPSBzYW5pdGl6ZUluVmFsdWUoX3Byb3BzLnZhbHVlKTtcblxuICAgIGlmICghdmFsdWUubGVuZ3RoKSB7XG4gICAgICB2YWx1ZSA9IHNhbml0aXplSW5WYWx1ZShfcHJvcHMuZGVmYXVsdFZhbHVlKTtcbiAgICB9IC8vIGFycmF5IGZvciBzdG9yaW5nIHJlc2l6ZSB0aW1lb3V0cyBpZHNcblxuXG4gICAgX3RoaXMucGVuZGluZ1Jlc2l6ZVRpbWVvdXRzID0gW107XG4gICAgY29uc3QgekluZGljZXMgPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIHZhbHVlW2ldID0gdHJpbUFsaWduVmFsdWUodmFsdWVbaV0sIF9wcm9wcyk7XG4gICAgICB6SW5kaWNlcy5wdXNoKGkpO1xuICAgIH1cblxuICAgIF90aGlzLnJlc2l6ZU9ic2VydmVyID0gbnVsbDtcbiAgICBfdGhpcy5yZXNpemVFbGVtZW50UmVmID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZVJlZigpO1xuICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgaW5kZXg6IC0xLFxuICAgICAgdXBwZXJCb3VuZDogMCxcbiAgICAgIHNsaWRlckxlbmd0aDogMCxcbiAgICAgIHZhbHVlLFxuICAgICAgekluZGljZXNcbiAgICB9O1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBSZWFjdFNsaWRlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzLnJlc2l6ZU9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKHRoaXMuaGFuZGxlUmVzaXplKTtcbiAgICAgIHRoaXMucmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLnJlc2l6ZUVsZW1lbnRSZWYuY3VycmVudCk7XG4gICAgICB0aGlzLnJlc2l6ZSgpO1xuICAgIH1cbiAgfSAvLyBLZWVwIHRoZSBpbnRlcm5hbCBgdmFsdWVgIGNvbnNpc3RlbnQgd2l0aCBhbiBvdXRzaWRlIGB2YWx1ZWAgaWYgcHJlc2VudC5cbiAgLy8gVGhpcyBiYXNpY2FsbHkgYWxsb3dzIHRoZSBzbGlkZXIgdG8gYmUgYSBjb250cm9sbGVkIGNvbXBvbmVudC5cbiAgO1xuXG4gIFJlYWN0U2xpZGVyLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9IGZ1bmN0aW9uIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhwcm9wcywgc3RhdGUpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHNhbml0aXplSW5WYWx1ZShwcm9wcy52YWx1ZSk7XG5cbiAgICBpZiAoIXZhbHVlLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSAvLyBEbyBub3QgYWxsb3cgY29udHJvbGxlZCB1cGF0ZXMgdG8gaGFwcGVuIHdoaWxlIHdlIGhhdmUgcGVuZGluZyB1cGRhdGVzXG5cblxuICAgIGlmIChzdGF0ZS5wZW5kaW5nKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IHZhbHVlLm1hcChpdGVtID0+IHRyaW1BbGlnblZhbHVlKGl0ZW0sIHByb3BzKSlcbiAgICB9O1xuICB9O1xuXG4gIF9wcm90by5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgLy8gSWYgYW4gdXBwZXJCb3VuZCBoYXMgbm90IHlldCBiZWVuIGRldGVybWluZWQgKGR1ZSB0byB0aGUgY29tcG9uZW50IGJlaW5nIGhpZGRlblxuICAgIC8vIGR1cmluZyB0aGUgbW91bnQgZXZlbnQsIG9yIGR1cmluZyB0aGUgbGFzdCByZXNpemUpLCB0aGVuIGNhbGN1bGF0ZSBpdCBub3dcbiAgICBpZiAodGhpcy5zdGF0ZS51cHBlckJvdW5kID09PSAwKSB7XG4gICAgICB0aGlzLnJlc2l6ZSgpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICB0aGlzLmNsZWFyUGVuZGluZ1Jlc2l6ZVRpbWVvdXRzKCk7XG5cbiAgICBpZiAodGhpcy5yZXNpemVPYnNlcnZlcikge1xuICAgICAgdGhpcy5yZXNpemVPYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5vbkVuZCA9IGZ1bmN0aW9uIG9uRW5kKGV2ZW50TWFwKSB7XG4gICAgaWYgKGV2ZW50TWFwKSB7XG4gICAgICByZW1vdmVIYW5kbGVycyhldmVudE1hcCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaGFzTW92ZWQpIHtcbiAgICAgIHRoaXMuZmlyZUNoYW5nZUV2ZW50KCdvbkFmdGVyQ2hhbmdlJyk7XG4gICAgfSAvLyBBbGxvdyBjb250cm9sbGVkIHVwZGF0ZXMgdG8gY29udGludWVcblxuXG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBwZW5kaW5nOiBmYWxzZVxuICAgIH0pO1xuICAgIHRoaXMuaGFzTW92ZWQgPSBmYWxzZTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0VmFsdWUgPSBmdW5jdGlvbiBnZXRWYWx1ZSgpIHtcbiAgICByZXR1cm4gcHJlcGFyZU91dFZhbHVlKHRoaXMuc3RhdGUudmFsdWUpO1xuICB9O1xuXG4gIF9wcm90by5nZXRDbG9zZXN0SW5kZXggPSBmdW5jdGlvbiBnZXRDbG9zZXN0SW5kZXgocGl4ZWxPZmZzZXQpIHtcbiAgICBsZXQgbWluRGlzdCA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgbGV0IGNsb3Nlc3RJbmRleCA9IC0xO1xuICAgIGNvbnN0IHtcbiAgICAgIHZhbHVlXG4gICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3QgbCA9IHZhbHVlLmxlbmd0aDtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbDsgaSArPSAxKSB7XG4gICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLmNhbGNPZmZzZXQodmFsdWVbaV0pO1xuICAgICAgY29uc3QgZGlzdCA9IE1hdGguYWJzKHBpeGVsT2Zmc2V0IC0gb2Zmc2V0KTtcblxuICAgICAgaWYgKGRpc3QgPCBtaW5EaXN0KSB7XG4gICAgICAgIG1pbkRpc3QgPSBkaXN0O1xuICAgICAgICBjbG9zZXN0SW5kZXggPSBpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjbG9zZXN0SW5kZXg7XG4gIH07XG5cbiAgX3Byb3RvLmdldE1vdXNlUG9zaXRpb24gPSBmdW5jdGlvbiBnZXRNb3VzZVBvc2l0aW9uKGUpIHtcbiAgICByZXR1cm4gW2VbXCJwYWdlXCIgKyB0aGlzLmF4aXNLZXkoKV0sIGVbXCJwYWdlXCIgKyB0aGlzLm9ydGhvZ29uYWxBeGlzS2V5KCldXTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0VG91Y2hQb3NpdGlvbiA9IGZ1bmN0aW9uIGdldFRvdWNoUG9zaXRpb24oZSkge1xuICAgIGNvbnN0IHRvdWNoID0gZS50b3VjaGVzWzBdO1xuICAgIHJldHVybiBbdG91Y2hbXCJwYWdlXCIgKyB0aGlzLmF4aXNLZXkoKV0sIHRvdWNoW1wicGFnZVwiICsgdGhpcy5vcnRob2dvbmFsQXhpc0tleSgpXV07XG4gIH07XG5cbiAgX3Byb3RvLmdldEtleURvd25FdmVudE1hcCA9IGZ1bmN0aW9uIGdldEtleURvd25FdmVudE1hcCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAga2V5ZG93bjogdGhpcy5vbktleURvd24sXG4gICAgICBrZXl1cDogdGhpcy5vbktleVVwLFxuICAgICAgZm9jdXNvdXQ6IHRoaXMub25CbHVyXG4gICAgfTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0TW91c2VFdmVudE1hcCA9IGZ1bmN0aW9uIGdldE1vdXNlRXZlbnRNYXAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1vdXNlbW92ZTogdGhpcy5vbk1vdXNlTW92ZSxcbiAgICAgIG1vdXNldXA6IHRoaXMub25Nb3VzZVVwXG4gICAgfTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0VG91Y2hFdmVudE1hcCA9IGZ1bmN0aW9uIGdldFRvdWNoRXZlbnRNYXAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRvdWNobW92ZTogdGhpcy5vblRvdWNoTW92ZSxcbiAgICAgIHRvdWNoZW5kOiB0aGlzLm9uVG91Y2hFbmRcbiAgICB9O1xuICB9O1xuXG4gIF9wcm90by5nZXRWYWx1ZUZyb21Qb3NpdGlvbiA9IGZ1bmN0aW9uIGdldFZhbHVlRnJvbVBvc2l0aW9uKHBvc2l0aW9uKSB7XG4gICAgY29uc3QgZGlmZlZhbHVlID0gcG9zaXRpb24gLyAodGhpcy5zdGF0ZS5zbGlkZXJMZW5ndGggLSB0aGlzLnN0YXRlLnRodW1iU2l6ZSkgKiAodGhpcy5wcm9wcy5tYXggLSB0aGlzLnByb3BzLm1pbik7XG4gICAgcmV0dXJuIHRyaW1BbGlnblZhbHVlKHRoaXMuc3RhdGUuc3RhcnRWYWx1ZSArIGRpZmZWYWx1ZSwgdGhpcy5wcm9wcyk7XG4gIH07XG5cbiAgX3Byb3RvLmdldERpZmZQb3NpdGlvbiA9IGZ1bmN0aW9uIGdldERpZmZQb3NpdGlvbihwb3NpdGlvbikge1xuICAgIGxldCBkaWZmUG9zaXRpb24gPSBwb3NpdGlvbiAtIHRoaXMuc3RhdGUuc3RhcnRQb3NpdGlvbjtcblxuICAgIGlmICh0aGlzLnByb3BzLmludmVydCkge1xuICAgICAgZGlmZlBvc2l0aW9uICo9IC0xO1xuICAgIH1cblxuICAgIHJldHVybiBkaWZmUG9zaXRpb247XG4gIH0gLy8gY3JlYXRlIHRoZSBga2V5ZG93bmAgaGFuZGxlciBmb3IgdGhlIGktdGggdGh1bWJcbiAgO1xuXG4gIF9wcm90by5yZXNpemUgPSBmdW5jdGlvbiByZXNpemUoKSB7XG4gICAgY29uc3Qge1xuICAgICAgc2xpZGVyLFxuICAgICAgdGh1bWIwOiB0aHVtYlxuICAgIH0gPSB0aGlzO1xuXG4gICAgaWYgKCFzbGlkZXIgfHwgIXRodW1iKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgc2l6ZUtleSA9IHRoaXMuc2l6ZUtleSgpOyAvLyBGb3IgdGhlIHNsaWRlciBzaXplLCB3ZSB3YW50IHRvIHVzZSB0aGUgY2xpZW50IHdpZHRoL2hlaWdodCwgZXhjbHVkaW5nIGFueSBib3JkZXJzXG5cbiAgICBjb25zdCBzbGlkZXJSZWN0ID0gc2xpZGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IHNsaWRlclNpemUgPSBzbGlkZXJbc2l6ZUtleV07XG4gICAgY29uc3Qgc2xpZGVyTWF4ID0gc2xpZGVyUmVjdFt0aGlzLnBvc01heEtleSgpXTtcbiAgICBjb25zdCBzbGlkZXJNaW4gPSBzbGlkZXJSZWN0W3RoaXMucG9zTWluS2V5KCldOyAvLyBGb3IgdGhlIHRodW1iIHNpemUsIHdlIHdhbnQgdG8gdXNlIHRoZSBvdXRlciB3aWR0aC9oZWlnaHQsIGluY2x1ZGluZyBhbnkgYm9yZGVyc1xuXG4gICAgY29uc3QgdGh1bWJSZWN0ID0gdGh1bWIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3QgdGh1bWJTaXplID0gdGh1bWJSZWN0W3NpemVLZXkucmVwbGFjZSgnY2xpZW50JywgJycpLnRvTG93ZXJDYXNlKCldO1xuICAgIGNvbnN0IHVwcGVyQm91bmQgPSBzbGlkZXJTaXplIC0gdGh1bWJTaXplO1xuICAgIGNvbnN0IHNsaWRlckxlbmd0aCA9IE1hdGguYWJzKHNsaWRlck1heCAtIHNsaWRlck1pbik7XG5cbiAgICBpZiAodGhpcy5zdGF0ZS51cHBlckJvdW5kICE9PSB1cHBlckJvdW5kIHx8IHRoaXMuc3RhdGUuc2xpZGVyTGVuZ3RoICE9PSBzbGlkZXJMZW5ndGggfHwgdGhpcy5zdGF0ZS50aHVtYlNpemUgIT09IHRodW1iU2l6ZSkge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIHVwcGVyQm91bmQsXG4gICAgICAgIHNsaWRlckxlbmd0aCxcbiAgICAgICAgdGh1bWJTaXplXG4gICAgICB9KTtcbiAgICB9XG4gIH0gLy8gY2FsY3VsYXRlcyB0aGUgb2Zmc2V0IG9mIGEgdGh1bWIgaW4gcGl4ZWxzIGJhc2VkIG9uIGl0cyB2YWx1ZS5cbiAgO1xuXG4gIF9wcm90by5jYWxjT2Zmc2V0ID0gZnVuY3Rpb24gY2FsY09mZnNldCh2YWx1ZSkge1xuICAgIGNvbnN0IHJhbmdlID0gdGhpcy5wcm9wcy5tYXggLSB0aGlzLnByb3BzLm1pbjtcblxuICAgIGlmIChyYW5nZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgY29uc3QgcmF0aW8gPSAodmFsdWUgLSB0aGlzLnByb3BzLm1pbikgLyByYW5nZTtcbiAgICByZXR1cm4gcmF0aW8gKiB0aGlzLnN0YXRlLnVwcGVyQm91bmQ7XG4gIH0gLy8gY2FsY3VsYXRlcyB0aGUgdmFsdWUgY29ycmVzcG9uZGluZyB0byBhIGdpdmVuIHBpeGVsIG9mZnNldCwgaS5lLiB0aGUgaW52ZXJzZSBvZiBgY2FsY09mZnNldGAuXG4gIDtcblxuICBfcHJvdG8uY2FsY1ZhbHVlID0gZnVuY3Rpb24gY2FsY1ZhbHVlKG9mZnNldCkge1xuICAgIGNvbnN0IHJhdGlvID0gb2Zmc2V0IC8gdGhpcy5zdGF0ZS51cHBlckJvdW5kO1xuICAgIHJldHVybiByYXRpbyAqICh0aGlzLnByb3BzLm1heCAtIHRoaXMucHJvcHMubWluKSArIHRoaXMucHJvcHMubWluO1xuICB9O1xuXG4gIF9wcm90by5jYWxjT2Zmc2V0RnJvbVBvc2l0aW9uID0gZnVuY3Rpb24gY2FsY09mZnNldEZyb21Qb3NpdGlvbihwb3NpdGlvbikge1xuICAgIGNvbnN0IHtcbiAgICAgIHNsaWRlclxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHNsaWRlclJlY3QgPSBzbGlkZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3Qgc2xpZGVyTWF4ID0gc2xpZGVyUmVjdFt0aGlzLnBvc01heEtleSgpXTtcbiAgICBjb25zdCBzbGlkZXJNaW4gPSBzbGlkZXJSZWN0W3RoaXMucG9zTWluS2V5KCldOyAvLyBUaGUgYHBvc2l0aW9uYCB2YWx1ZSBwYXNzZWQgaW4gaXMgdGhlIG1vdXNlIHBvc2l0aW9uIGJhc2VkIG9uIHRoZSB3aW5kb3cgaGVpZ2h0LlxuICAgIC8vIFRoZSBzbGlkZXIgYm91bmRpbmcgcmVjdCBpcyBiYXNlZCBvbiB0aGUgdmlld3BvcnQsIHNvIHdlIG11c3QgYWRkIHRoZSB3aW5kb3cgc2Nyb2xsXG4gICAgLy8gb2Zmc2V0IHRvIG5vcm1hbGl6ZSB0aGUgdmFsdWVzLlxuXG4gICAgY29uc3Qgd2luZG93T2Zmc2V0ID0gd2luZG93W1wicGFnZVwiICsgdGhpcy5heGlzS2V5KCkgKyBcIk9mZnNldFwiXTtcbiAgICBjb25zdCBzbGlkZXJTdGFydCA9IHdpbmRvd09mZnNldCArICh0aGlzLnByb3BzLmludmVydCA/IHNsaWRlck1heCA6IHNsaWRlck1pbik7XG4gICAgbGV0IHBpeGVsT2Zmc2V0ID0gcG9zaXRpb24gLSBzbGlkZXJTdGFydDtcblxuICAgIGlmICh0aGlzLnByb3BzLmludmVydCkge1xuICAgICAgcGl4ZWxPZmZzZXQgPSB0aGlzLnN0YXRlLnNsaWRlckxlbmd0aCAtIHBpeGVsT2Zmc2V0O1xuICAgIH1cblxuICAgIHBpeGVsT2Zmc2V0IC09IHRoaXMuc3RhdGUudGh1bWJTaXplIC8gMjtcbiAgICByZXR1cm4gcGl4ZWxPZmZzZXQ7XG4gIH0gLy8gU25hcHMgdGhlIG5lYXJlc3QgdGh1bWIgdG8gdGhlIHZhbHVlIGNvcnJlc3BvbmRpbmcgdG8gYHBvc2l0aW9uYFxuICAvLyBhbmQgY2FsbHMgYGNhbGxiYWNrYCB3aXRoIHRoYXQgdGh1bWIncyBpbmRleC5cbiAgO1xuXG4gIF9wcm90by5mb3JjZVZhbHVlRnJvbVBvc2l0aW9uID0gZnVuY3Rpb24gZm9yY2VWYWx1ZUZyb21Qb3NpdGlvbihwb3NpdGlvbiwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBwaXhlbE9mZnNldCA9IHRoaXMuY2FsY09mZnNldEZyb21Qb3NpdGlvbihwb3NpdGlvbik7XG4gICAgY29uc3QgY2xvc2VzdEluZGV4ID0gdGhpcy5nZXRDbG9zZXN0SW5kZXgocGl4ZWxPZmZzZXQpO1xuICAgIGNvbnN0IG5leHRWYWx1ZSA9IHRyaW1BbGlnblZhbHVlKHRoaXMuY2FsY1ZhbHVlKHBpeGVsT2Zmc2V0KSwgdGhpcy5wcm9wcyk7IC8vIENsb25lIHRoaXMuc3RhdGUudmFsdWUgc2luY2Ugd2UnbGwgbW9kaWZ5IGl0IHRlbXBvcmFyaWx5XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHppbGxvdy9yZWFjdC9uby1hY2Nlc3Mtc3RhdGUtaW4tc2V0c3RhdGVcblxuICAgIGNvbnN0IHZhbHVlID0gdGhpcy5zdGF0ZS52YWx1ZS5zbGljZSgpO1xuICAgIHZhbHVlW2Nsb3Nlc3RJbmRleF0gPSBuZXh0VmFsdWU7IC8vIFByZXZlbnRzIHRoZSBzbGlkZXIgZnJvbSBzaHJpbmtpbmcgYmVsb3cgYHByb3BzLm1pbkRpc3RhbmNlYFxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGggLSAxOyBpICs9IDEpIHtcbiAgICAgIGlmICh2YWx1ZVtpICsgMV0gLSB2YWx1ZVtpXSA8IHRoaXMucHJvcHMubWluRGlzdGFuY2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuZmlyZUNoYW5nZUV2ZW50KCdvbkJlZm9yZUNoYW5nZScpO1xuICAgIHRoaXMuaGFzTW92ZWQgPSB0cnVlO1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgdmFsdWVcbiAgICB9LCAoKSA9PiB7XG4gICAgICBjYWxsYmFjayhjbG9zZXN0SW5kZXgpO1xuICAgICAgdGhpcy5maXJlQ2hhbmdlRXZlbnQoJ29uQ2hhbmdlJyk7XG4gICAgfSk7XG4gIH0gLy8gY2xlYXIgYWxsIHBlbmRpbmcgdGltZW91dHMgdG8gYXZvaWQgZXJyb3IgbWVzc2FnZXMgYWZ0ZXIgdW5tb3VudGluZ1xuICA7XG5cbiAgX3Byb3RvLmNsZWFyUGVuZGluZ1Jlc2l6ZVRpbWVvdXRzID0gZnVuY3Rpb24gY2xlYXJQZW5kaW5nUmVzaXplVGltZW91dHMoKSB7XG4gICAgZG8ge1xuICAgICAgY29uc3QgbmV4dFRpbWVvdXQgPSB0aGlzLnBlbmRpbmdSZXNpemVUaW1lb3V0cy5zaGlmdCgpO1xuICAgICAgY2xlYXJUaW1lb3V0KG5leHRUaW1lb3V0KTtcbiAgICB9IHdoaWxlICh0aGlzLnBlbmRpbmdSZXNpemVUaW1lb3V0cy5sZW5ndGgpO1xuICB9O1xuXG4gIF9wcm90by5zdGFydCA9IGZ1bmN0aW9uIHN0YXJ0KGksIHBvc2l0aW9uKSB7XG4gICAgY29uc3QgdGh1bWJSZWYgPSB0aGlzW1widGh1bWJcIiArIGldO1xuXG4gICAgaWYgKHRodW1iUmVmKSB7XG4gICAgICB0aHVtYlJlZi5mb2N1cygpO1xuICAgIH1cblxuICAgIGNvbnN0IHtcbiAgICAgIHpJbmRpY2VzXG4gICAgfSA9IHRoaXMuc3RhdGU7IC8vIHJlbW92ZSB3aGVyZXZlciB0aGUgZWxlbWVudCBpc1xuXG4gICAgekluZGljZXMuc3BsaWNlKHpJbmRpY2VzLmluZGV4T2YoaSksIDEpOyAvLyBhZGQgdG8gZW5kXG5cbiAgICB6SW5kaWNlcy5wdXNoKGkpO1xuICAgIHRoaXMuc2V0U3RhdGUocHJldlN0YXRlID0+ICh7XG4gICAgICBzdGFydFZhbHVlOiBwcmV2U3RhdGUudmFsdWVbaV0sXG4gICAgICBzdGFydFBvc2l0aW9uOiBwb3NpdGlvbiAhPT0gdW5kZWZpbmVkID8gcG9zaXRpb24gOiBwcmV2U3RhdGUuc3RhcnRQb3NpdGlvbixcbiAgICAgIGluZGV4OiBpLFxuICAgICAgekluZGljZXNcbiAgICB9KSk7XG4gIH07XG5cbiAgX3Byb3RvLm1vdmVVcEJ5U3RlcCA9IGZ1bmN0aW9uIG1vdmVVcEJ5U3RlcChzdGVwKSB7XG4gICAgaWYgKHN0ZXAgPT09IHZvaWQgMCkge1xuICAgICAgc3RlcCA9IHRoaXMucHJvcHMuc3RlcDtcbiAgICB9XG5cbiAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXMuc3RhdGUudmFsdWVbdGhpcy5zdGF0ZS5pbmRleF07XG4gICAgY29uc3QgbmV3VmFsdWUgPSB0cmltQWxpZ25WYWx1ZShvbGRWYWx1ZSArIHN0ZXAsIHRoaXMucHJvcHMpO1xuICAgIHRoaXMubW92ZShNYXRoLm1pbihuZXdWYWx1ZSwgdGhpcy5wcm9wcy5tYXgpKTtcbiAgfTtcblxuICBfcHJvdG8ubW92ZURvd25CeVN0ZXAgPSBmdW5jdGlvbiBtb3ZlRG93bkJ5U3RlcChzdGVwKSB7XG4gICAgaWYgKHN0ZXAgPT09IHZvaWQgMCkge1xuICAgICAgc3RlcCA9IHRoaXMucHJvcHMuc3RlcDtcbiAgICB9XG5cbiAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXMuc3RhdGUudmFsdWVbdGhpcy5zdGF0ZS5pbmRleF07XG4gICAgY29uc3QgbmV3VmFsdWUgPSB0cmltQWxpZ25WYWx1ZShvbGRWYWx1ZSAtIHN0ZXAsIHRoaXMucHJvcHMpO1xuICAgIHRoaXMubW92ZShNYXRoLm1heChuZXdWYWx1ZSwgdGhpcy5wcm9wcy5taW4pKTtcbiAgfTtcblxuICBfcHJvdG8ubW92ZSA9IGZ1bmN0aW9uIG1vdmUobmV3VmFsdWUpIHtcbiAgICBjb25zdCB7XG4gICAgICBpbmRleCxcbiAgICAgIHZhbHVlXG4gICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3Qge1xuICAgICAgbGVuZ3RoXG4gICAgfSA9IHZhbHVlOyAvLyBTaG9ydCBjaXJjdWl0IGlmIHRoZSB2YWx1ZSBpcyBub3QgY2hhbmdpbmdcblxuICAgIGNvbnN0IG9sZFZhbHVlID0gdmFsdWVbaW5kZXhdO1xuXG4gICAgaWYgKG5ld1ZhbHVlID09PSBvbGRWYWx1ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gVHJpZ2dlciBvbmx5IGJlZm9yZSB0aGUgZmlyc3QgbW92ZW1lbnRcblxuXG4gICAgaWYgKCF0aGlzLmhhc01vdmVkKSB7XG4gICAgICB0aGlzLmZpcmVDaGFuZ2VFdmVudCgnb25CZWZvcmVDaGFuZ2UnKTtcbiAgICB9XG5cbiAgICB0aGlzLmhhc01vdmVkID0gdHJ1ZTsgLy8gaWYgXCJwZWFybGluZ1wiICg9IHRodW1icyBwdXNoaW5nIGVhY2ggb3RoZXIpIGlzIGRpc2FibGVkLFxuICAgIC8vIHByZXZlbnQgdGhlIHRodW1iIGZyb20gZ2V0dGluZyBjbG9zZXIgdGhhbiBgbWluRGlzdGFuY2VgIHRvIHRoZSBwcmV2aW91cyBvciBuZXh0IHRodW1iLlxuXG4gICAgY29uc3Qge1xuICAgICAgcGVhcmxpbmcsXG4gICAgICBtYXgsXG4gICAgICBtaW4sXG4gICAgICBtaW5EaXN0YW5jZVxuICAgIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgaWYgKCFwZWFybGluZykge1xuICAgICAgaWYgKGluZGV4ID4gMCkge1xuICAgICAgICBjb25zdCB2YWx1ZUJlZm9yZSA9IHZhbHVlW2luZGV4IC0gMV07XG5cbiAgICAgICAgaWYgKG5ld1ZhbHVlIDwgdmFsdWVCZWZvcmUgKyBtaW5EaXN0YW5jZSkge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgIG5ld1ZhbHVlID0gdmFsdWVCZWZvcmUgKyBtaW5EaXN0YW5jZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaW5kZXggPCBsZW5ndGggLSAxKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlQWZ0ZXIgPSB2YWx1ZVtpbmRleCArIDFdO1xuXG4gICAgICAgIGlmIChuZXdWYWx1ZSA+IHZhbHVlQWZ0ZXIgLSBtaW5EaXN0YW5jZSkge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgIG5ld1ZhbHVlID0gdmFsdWVBZnRlciAtIG1pbkRpc3RhbmNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFsdWVbaW5kZXhdID0gbmV3VmFsdWU7IC8vIGlmIFwicGVhcmxpbmdcIiBpcyBlbmFibGVkLCBsZXQgdGhlIGN1cnJlbnQgdGh1bWIgcHVzaCB0aGUgcHJlLSBhbmQgc3VjY2VlZGluZyB0aHVtYnMuXG5cbiAgICBpZiAocGVhcmxpbmcgJiYgbGVuZ3RoID4gMSkge1xuICAgICAgaWYgKG5ld1ZhbHVlID4gb2xkVmFsdWUpIHtcbiAgICAgICAgdGhpcy5wdXNoU3VjY2VlZGluZyh2YWx1ZSwgbWluRGlzdGFuY2UsIGluZGV4KTtcbiAgICAgICAgdHJpbVN1Y2NlZWRpbmcobGVuZ3RoLCB2YWx1ZSwgbWluRGlzdGFuY2UsIG1heCk7XG4gICAgICB9IGVsc2UgaWYgKG5ld1ZhbHVlIDwgb2xkVmFsdWUpIHtcbiAgICAgICAgdGhpcy5wdXNoUHJlY2VkaW5nKHZhbHVlLCBtaW5EaXN0YW5jZSwgaW5kZXgpO1xuICAgICAgICB0cmltUHJlY2VkaW5nKGxlbmd0aCwgdmFsdWUsIG1pbkRpc3RhbmNlLCBtaW4pO1xuICAgICAgfVxuICAgIH0gLy8gTm9ybWFsbHkgeW91IHdvdWxkIHVzZSBgc2hvdWxkQ29tcG9uZW50VXBkYXRlYCxcbiAgICAvLyBidXQgc2luY2UgdGhlIHNsaWRlciBpcyBhIGxvdy1sZXZlbCBjb21wb25lbnQsXG4gICAgLy8gdGhlIGV4dHJhIGNvbXBsZXhpdHkgbWlnaHQgYmUgd29ydGggdGhlIGV4dHJhIHBlcmZvcm1hbmNlLlxuXG5cbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIHZhbHVlXG4gICAgfSwgdGhpcy5maXJlQ2hhbmdlRXZlbnQuYmluZCh0aGlzLCAnb25DaGFuZ2UnKSk7XG4gIH07XG5cbiAgX3Byb3RvLnB1c2hTdWNjZWVkaW5nID0gZnVuY3Rpb24gcHVzaFN1Y2NlZWRpbmcodmFsdWUsIG1pbkRpc3RhbmNlLCBpbmRleCkge1xuICAgIGxldCBpO1xuICAgIGxldCBwYWRkaW5nO1xuXG4gICAgZm9yIChpID0gaW5kZXgsIHBhZGRpbmcgPSB2YWx1ZVtpXSArIG1pbkRpc3RhbmNlOyB2YWx1ZVtpICsgMV0gIT09IG51bGwgJiYgcGFkZGluZyA+IHZhbHVlW2kgKyAxXTsgaSArPSAxLCBwYWRkaW5nID0gdmFsdWVbaV0gKyBtaW5EaXN0YW5jZSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICB2YWx1ZVtpICsgMV0gPSBhbGlnblZhbHVlKHBhZGRpbmcsIHRoaXMucHJvcHMpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ucHVzaFByZWNlZGluZyA9IGZ1bmN0aW9uIHB1c2hQcmVjZWRpbmcodmFsdWUsIG1pbkRpc3RhbmNlLCBpbmRleCkge1xuICAgIGZvciAobGV0IGkgPSBpbmRleCwgcGFkZGluZyA9IHZhbHVlW2ldIC0gbWluRGlzdGFuY2U7IHZhbHVlW2kgLSAxXSAhPT0gbnVsbCAmJiBwYWRkaW5nIDwgdmFsdWVbaSAtIDFdOyBpIC09IDEsIHBhZGRpbmcgPSB2YWx1ZVtpXSAtIG1pbkRpc3RhbmNlKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgIHZhbHVlW2kgLSAxXSA9IGFsaWduVmFsdWUocGFkZGluZywgdGhpcy5wcm9wcyk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5heGlzS2V5ID0gZnVuY3Rpb24gYXhpc0tleSgpIHtcbiAgICBpZiAodGhpcy5wcm9wcy5vcmllbnRhdGlvbiA9PT0gJ3ZlcnRpY2FsJykge1xuICAgICAgcmV0dXJuICdZJztcbiAgICB9IC8vIERlZmF1bHRzIHRvICdob3Jpem9udGFsJztcblxuXG4gICAgcmV0dXJuICdYJztcbiAgfTtcblxuICBfcHJvdG8ub3J0aG9nb25hbEF4aXNLZXkgPSBmdW5jdGlvbiBvcnRob2dvbmFsQXhpc0tleSgpIHtcbiAgICBpZiAodGhpcy5wcm9wcy5vcmllbnRhdGlvbiA9PT0gJ3ZlcnRpY2FsJykge1xuICAgICAgcmV0dXJuICdYJztcbiAgICB9IC8vIERlZmF1bHRzIHRvICdob3Jpem9udGFsJ1xuXG5cbiAgICByZXR1cm4gJ1knO1xuICB9O1xuXG4gIF9wcm90by5wb3NNaW5LZXkgPSBmdW5jdGlvbiBwb3NNaW5LZXkoKSB7XG4gICAgaWYgKHRoaXMucHJvcHMub3JpZW50YXRpb24gPT09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgIHJldHVybiB0aGlzLnByb3BzLmludmVydCA/ICdib3R0b20nIDogJ3RvcCc7XG4gICAgfSAvLyBEZWZhdWx0cyB0byAnaG9yaXpvbnRhbCdcblxuXG4gICAgcmV0dXJuIHRoaXMucHJvcHMuaW52ZXJ0ID8gJ3JpZ2h0JyA6ICdsZWZ0JztcbiAgfTtcblxuICBfcHJvdG8ucG9zTWF4S2V5ID0gZnVuY3Rpb24gcG9zTWF4S2V5KCkge1xuICAgIGlmICh0aGlzLnByb3BzLm9yaWVudGF0aW9uID09PSAndmVydGljYWwnKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcm9wcy5pbnZlcnQgPyAndG9wJyA6ICdib3R0b20nO1xuICAgIH0gLy8gRGVmYXVsdHMgdG8gJ2hvcml6b250YWwnXG5cblxuICAgIHJldHVybiB0aGlzLnByb3BzLmludmVydCA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gIH07XG5cbiAgX3Byb3RvLnNpemVLZXkgPSBmdW5jdGlvbiBzaXplS2V5KCkge1xuICAgIGlmICh0aGlzLnByb3BzLm9yaWVudGF0aW9uID09PSAndmVydGljYWwnKSB7XG4gICAgICByZXR1cm4gJ2NsaWVudEhlaWdodCc7XG4gICAgfSAvLyBEZWZhdWx0cyB0byAnaG9yaXpvbnRhbCdcblxuXG4gICAgcmV0dXJuICdjbGllbnRXaWR0aCc7XG4gIH07XG5cbiAgX3Byb3RvLmZpcmVDaGFuZ2VFdmVudCA9IGZ1bmN0aW9uIGZpcmVDaGFuZ2VFdmVudChldmVudCkge1xuICAgIGlmICh0aGlzLnByb3BzW2V2ZW50XSkge1xuICAgICAgdGhpcy5wcm9wc1tldmVudF0ocHJlcGFyZU91dFZhbHVlKHRoaXMuc3RhdGUudmFsdWUpLCB0aGlzLnN0YXRlLmluZGV4KTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmJ1aWxkVGh1bWJTdHlsZSA9IGZ1bmN0aW9uIGJ1aWxkVGh1bWJTdHlsZShvZmZzZXQsIGkpIHtcbiAgICBjb25zdCBzdHlsZSA9IHtcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgdG91Y2hBY3Rpb246ICdub25lJyxcbiAgICAgIHdpbGxDaGFuZ2U6IHRoaXMuc3RhdGUuaW5kZXggPj0gMCA/IHRoaXMucG9zTWluS2V5KCkgOiB1bmRlZmluZWQsXG4gICAgICB6SW5kZXg6IHRoaXMuc3RhdGUuekluZGljZXMuaW5kZXhPZihpKSArIDFcbiAgICB9O1xuICAgIHN0eWxlW3RoaXMucG9zTWluS2V5KCldID0gb2Zmc2V0ICsgXCJweFwiO1xuICAgIHJldHVybiBzdHlsZTtcbiAgfTtcblxuICBfcHJvdG8uYnVpbGRUcmFja1N0eWxlID0gZnVuY3Rpb24gYnVpbGRUcmFja1N0eWxlKG1pbiwgbWF4KSB7XG4gICAgY29uc3Qgb2JqID0ge1xuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICB3aWxsQ2hhbmdlOiB0aGlzLnN0YXRlLmluZGV4ID49IDAgPyB0aGlzLnBvc01pbktleSgpICsgXCIsXCIgKyB0aGlzLnBvc01heEtleSgpIDogdW5kZWZpbmVkXG4gICAgfTtcbiAgICBvYmpbdGhpcy5wb3NNaW5LZXkoKV0gPSBtaW47XG4gICAgb2JqW3RoaXMucG9zTWF4S2V5KCldID0gbWF4O1xuICAgIHJldHVybiBvYmo7XG4gIH07XG5cbiAgX3Byb3RvLmJ1aWxkTWFya1N0eWxlID0gZnVuY3Rpb24gYnVpbGRNYXJrU3R5bGUob2Zmc2V0KSB7XG4gICAgdmFyIF9yZWY7XG5cbiAgICByZXR1cm4gX3JlZiA9IHtcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnXG4gICAgfSwgX3JlZlt0aGlzLnBvc01pbktleSgpXSA9IG9mZnNldCwgX3JlZjtcbiAgfTtcblxuICBfcHJvdG8ucmVuZGVyVGh1bWJzID0gZnVuY3Rpb24gcmVuZGVyVGh1bWJzKG9mZnNldCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGxlbmd0aFxuICAgIH0gPSBvZmZzZXQ7XG4gICAgY29uc3Qgc3R5bGVzID0gW107XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBzdHlsZXNbaV0gPSB0aGlzLmJ1aWxkVGh1bWJTdHlsZShvZmZzZXRbaV0sIGkpO1xuICAgIH1cblxuICAgIGNvbnN0IHJlcyA9IFtdO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgICAgcmVzW2ldID0gdGhpcy5yZW5kZXJUaHVtYihzdHlsZXNbaV0sIGkpO1xuICAgIH1cblxuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgX3Byb3RvLnJlbmRlclRyYWNrcyA9IGZ1bmN0aW9uIHJlbmRlclRyYWNrcyhvZmZzZXQpIHtcbiAgICBjb25zdCB0cmFja3MgPSBbXTtcbiAgICBjb25zdCBsYXN0SW5kZXggPSBvZmZzZXQubGVuZ3RoIC0gMTtcbiAgICB0cmFja3MucHVzaCh0aGlzLnJlbmRlclRyYWNrKDAsIDAsIG9mZnNldFswXSkpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsYXN0SW5kZXg7IGkgKz0gMSkge1xuICAgICAgdHJhY2tzLnB1c2godGhpcy5yZW5kZXJUcmFjayhpICsgMSwgb2Zmc2V0W2ldLCBvZmZzZXRbaSArIDFdKSk7XG4gICAgfVxuXG4gICAgdHJhY2tzLnB1c2godGhpcy5yZW5kZXJUcmFjayhsYXN0SW5kZXggKyAxLCBvZmZzZXRbbGFzdEluZGV4XSwgdGhpcy5zdGF0ZS51cHBlckJvdW5kKSk7XG4gICAgcmV0dXJuIHRyYWNrcztcbiAgfTtcblxuICBfcHJvdG8ucmVuZGVyTWFya3MgPSBmdW5jdGlvbiByZW5kZXJNYXJrcygpIHtcbiAgICBsZXQge1xuICAgICAgbWFya3NcbiAgICB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCByYW5nZSA9IHRoaXMucHJvcHMubWF4IC0gdGhpcy5wcm9wcy5taW4gKyAxO1xuXG4gICAgaWYgKHR5cGVvZiBtYXJrcyA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICBtYXJrcyA9IEFycmF5LmZyb20oe1xuICAgICAgICBsZW5ndGg6IHJhbmdlXG4gICAgICB9KS5tYXAoKF8sIGtleSkgPT4ga2V5KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtYXJrcyA9PT0gJ251bWJlcicpIHtcbiAgICAgIG1hcmtzID0gQXJyYXkuZnJvbSh7XG4gICAgICAgIGxlbmd0aDogcmFuZ2VcbiAgICAgIH0pLm1hcCgoXywga2V5KSA9PiBrZXkpLmZpbHRlcihrZXkgPT4ga2V5ICUgbWFya3MgPT09IDApO1xuICAgIH1cblxuICAgIHJldHVybiBtYXJrcy5tYXAocGFyc2VGbG9hdCkuc29ydCgoYSwgYikgPT4gYSAtIGIpLm1hcChtYXJrID0+IHtcbiAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuY2FsY09mZnNldChtYXJrKTtcbiAgICAgIGNvbnN0IHByb3BzID0ge1xuICAgICAgICBrZXk6IG1hcmssXG4gICAgICAgIGNsYXNzTmFtZTogdGhpcy5wcm9wcy5tYXJrQ2xhc3NOYW1lLFxuICAgICAgICBzdHlsZTogdGhpcy5idWlsZE1hcmtTdHlsZShvZmZzZXQpXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHRoaXMucHJvcHMucmVuZGVyTWFyayhwcm9wcyk7XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICBjb25zdCBvZmZzZXQgPSBbXTtcbiAgICBjb25zdCB7XG4gICAgICB2YWx1ZVxuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IGwgPSB2YWx1ZS5sZW5ndGg7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGw7IGkgKz0gMSkge1xuICAgICAgb2Zmc2V0W2ldID0gdGhpcy5jYWxjT2Zmc2V0KHZhbHVlW2ldLCBpKTtcbiAgICB9XG5cbiAgICBjb25zdCB0cmFja3MgPSB0aGlzLnByb3BzLndpdGhUcmFja3MgPyB0aGlzLnJlbmRlclRyYWNrcyhvZmZzZXQpIDogbnVsbDtcbiAgICBjb25zdCB0aHVtYnMgPSB0aGlzLnJlbmRlclRodW1icyhvZmZzZXQpO1xuICAgIGNvbnN0IG1hcmtzID0gdGhpcy5wcm9wcy5tYXJrcyA/IHRoaXMucmVuZGVyTWFya3MoKSA6IG51bGw7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KCdkaXYnLCB7XG4gICAgICByZWY6IHIgPT4ge1xuICAgICAgICB0aGlzLnNsaWRlciA9IHI7XG4gICAgICAgIHRoaXMucmVzaXplRWxlbWVudFJlZi5jdXJyZW50ID0gcjtcbiAgICAgIH0sXG4gICAgICBzdHlsZToge1xuICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJ1xuICAgICAgfSxcbiAgICAgIGNsYXNzTmFtZTogdGhpcy5wcm9wcy5jbGFzc05hbWUgKyAodGhpcy5wcm9wcy5kaXNhYmxlZCA/ICcgZGlzYWJsZWQnIDogJycpLFxuICAgICAgb25Nb3VzZURvd246IHRoaXMub25TbGlkZXJNb3VzZURvd24sXG4gICAgICBvbkNsaWNrOiB0aGlzLm9uU2xpZGVyQ2xpY2tcbiAgICB9LCB0cmFja3MsIHRodW1icywgbWFya3MpO1xuICB9O1xuXG4gIHJldHVybiBSZWFjdFNsaWRlcjtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuUmVhY3RTbGlkZXIuZGlzcGxheU5hbWUgPSAnUmVhY3RTbGlkZXInO1xuUmVhY3RTbGlkZXIuZGVmYXVsdFByb3BzID0ge1xuICBtaW46IDAsXG4gIG1heDogMTAwLFxuICBzdGVwOiAxLFxuICBwYWdlRm46IHN0ZXAgPT4gc3RlcCAqIDEwLFxuICBtaW5EaXN0YW5jZTogMCxcbiAgZGVmYXVsdFZhbHVlOiAwLFxuICBvcmllbnRhdGlvbjogJ2hvcml6b250YWwnLFxuICBjbGFzc05hbWU6ICdzbGlkZXInLFxuICB0aHVtYkNsYXNzTmFtZTogJ3RodW1iJyxcbiAgdGh1bWJBY3RpdmVDbGFzc05hbWU6ICdhY3RpdmUnLFxuICB0cmFja0NsYXNzTmFtZTogJ3RyYWNrJyxcbiAgbWFya0NsYXNzTmFtZTogJ21hcmsnLFxuICB3aXRoVHJhY2tzOiB0cnVlLFxuICBwZWFybGluZzogZmFsc2UsXG4gIGRpc2FibGVkOiBmYWxzZSxcbiAgc25hcERyYWdEaXNhYmxlZDogZmFsc2UsXG4gIGludmVydDogZmFsc2UsXG4gIG1hcmtzOiBbXSxcbiAgcmVuZGVyVGh1bWI6IHByb3BzID0+IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIF9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgIF9fc2VsZjogUmVhY3RTbGlkZXIsXG4gICAgX19zb3VyY2U6IHtcbiAgICAgIGZpbGVOYW1lOiBfanN4RmlsZU5hbWUsXG4gICAgICBsaW5lTnVtYmVyOiAzNTMsXG4gICAgICBjb2x1bW5OdW1iZXI6IDMxXG4gICAgfVxuICB9KSksXG4gIHJlbmRlclRyYWNrOiBwcm9wcyA9PiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgICBfX3NlbGY6IFJlYWN0U2xpZGVyLFxuICAgIF9fc291cmNlOiB7XG4gICAgICBmaWxlTmFtZTogX2pzeEZpbGVOYW1lLFxuICAgICAgbGluZU51bWJlcjogMzU0LFxuICAgICAgY29sdW1uTnVtYmVyOiAzMVxuICAgIH1cbiAgfSkpLFxuICByZW5kZXJNYXJrOiBwcm9wcyA9PiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgX19zZWxmOiBSZWFjdFNsaWRlcixcbiAgICBfX3NvdXJjZToge1xuICAgICAgZmlsZU5hbWU6IF9qc3hGaWxlTmFtZSxcbiAgICAgIGxpbmVOdW1iZXI6IDM1NSxcbiAgICAgIGNvbHVtbk51bWJlcjogMzBcbiAgICB9XG4gIH0pKVxufTtcblJlYWN0U2xpZGVyLnByb3BUeXBlcyA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHtcbiAgLyoqXG4gICAqIFRoZSBtaW5pbXVtIHZhbHVlIG9mIHRoZSBzbGlkZXIuXG4gICAqL1xuICBtaW46IFByb3BUeXBlcy5udW1iZXIsXG5cbiAgLyoqXG4gICAqIFRoZSBtYXhpbXVtIHZhbHVlIG9mIHRoZSBzbGlkZXIuXG4gICAqL1xuICBtYXg6IFByb3BUeXBlcy5udW1iZXIsXG5cbiAgLyoqXG4gICAqIFZhbHVlIHRvIGJlIGFkZGVkIG9yIHN1YnRyYWN0ZWQgb24gZWFjaCBzdGVwIHRoZSBzbGlkZXIgbWFrZXMuXG4gICAqIE11c3QgYmUgZ3JlYXRlciB0aGFuIHplcm8uXG4gICAqIGBtYXggLSBtaW5gIHNob3VsZCBiZSBldmVubHkgZGl2aXNpYmxlIGJ5IHRoZSBzdGVwIHZhbHVlLlxuICAgKi9cbiAgc3RlcDogUHJvcFR5cGVzLm51bWJlcixcblxuICAvKipcbiAgICogVGhlIHJlc3VsdCBvZiB0aGUgZnVuY3Rpb24gaXMgdGhlIHZhbHVlIHRvIGJlIGFkZGVkIG9yIHN1YnRyYWN0ZWRcbiAgICogd2hlbiB0aGUgYFBhZ2UgVXBgIG9yIGBQYWdlIERvd25gIGtleXMgYXJlIHByZXNzZWQuXG4gICAqXG4gICAqIFRoZSBjdXJyZW50IGBzdGVwYCB2YWx1ZSB3aWxsIGJlIHBhc3NlZCBhcyB0aGUgb25seSBhcmd1bWVudC5cbiAgICogQnkgZGVmYXVsdCwgcGFnaW5nIHdpbGwgbW9kaWZ5IGBzdGVwYCBieSBhIGZhY3RvciBvZiAxMC5cbiAgICovXG4gIHBhZ2VGbjogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIFRoZSBtaW5pbWFsIGRpc3RhbmNlIGJldHdlZW4gYW55IHBhaXIgb2YgdGh1bWJzLlxuICAgKiBNdXN0IGJlIHBvc2l0aXZlLCBidXQgemVybyBtZWFucyB0aGV5IGNhbiBzaXQgb24gdG9wIG9mIGVhY2ggb3RoZXIuXG4gICAqL1xuICBtaW5EaXN0YW5jZTogUHJvcFR5cGVzLm51bWJlcixcblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyB0aGUgaW5pdGlhbCBwb3NpdGlvbnMgb2YgdGhlIHRodW1icyBhbmQgdGhlIG51bWJlciBvZiB0aHVtYnMuXG4gICAqXG4gICAqIElmIGEgbnVtYmVyIGlzIHBhc3NlZCBhIHNsaWRlciB3aXRoIG9uZSB0aHVtYiB3aWxsIGJlIHJlbmRlcmVkLlxuICAgKiBJZiBhbiBhcnJheSBpcyBwYXNzZWQgZWFjaCB2YWx1ZSB3aWxsIGRldGVybWluZSB0aGUgcG9zaXRpb24gb2Ygb25lIHRodW1iLlxuICAgKiBUaGUgdmFsdWVzIGluIHRoZSBhcnJheSBtdXN0IGJlIHNvcnRlZC5cbiAgICovXG4gIGRlZmF1bHRWYWx1ZTogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm51bWJlciwgUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLm51bWJlcildKSxcblxuICAvKipcbiAgICogTGlrZSBgZGVmYXVsdFZhbHVlYCBidXQgZm9yXG4gICAqIFtjb250cm9sbGVkIGNvbXBvbmVudHNdKGh0dHA6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy9mb3Jtcy5odG1sI2NvbnRyb2xsZWQtY29tcG9uZW50cykuXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgemlsbG93L3JlYWN0L3JlcXVpcmUtZGVmYXVsdC1wcm9wc1xuICB2YWx1ZTogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm51bWJlciwgUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLm51bWJlcildKSxcblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBzbGlkZXIgbW92ZXMgaG9yaXpvbnRhbGx5IChmcm9tIGxlZnQgdG8gcmlnaHQpXG4gICAqIG9yIHZlcnRpY2FsbHkgKGZyb20gdG9wIHRvIGJvdHRvbSkuXG4gICAqL1xuICBvcmllbnRhdGlvbjogUHJvcFR5cGVzLm9uZU9mKFsnaG9yaXpvbnRhbCcsICd2ZXJ0aWNhbCddKSxcblxuICAvKipcbiAgICogVGhlIGNzcyBjbGFzcyBzZXQgb24gdGhlIHNsaWRlciBub2RlLlxuICAgKi9cbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuXG4gIC8qKlxuICAgKiBUaGUgY3NzIGNsYXNzIHNldCBvbiBlYWNoIHRodW1iIG5vZGUuXG4gICAqXG4gICAqIEluIGFkZGl0aW9uIGVhY2ggdGh1bWIgd2lsbCByZWNlaXZlIGEgbnVtYmVyZWQgY3NzIGNsYXNzIG9mIHRoZSBmb3JtXG4gICAqIGAke3RodW1iQ2xhc3NOYW1lfS0ke2l9YCwgZS5nLiBgdGh1bWItMGAsIGB0aHVtYi0xYCwgLi4uXG4gICAqL1xuICB0aHVtYkNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcblxuICAvKipcbiAgICogVGhlIGNzcyBjbGFzcyBzZXQgb24gdGhlIHRodW1iIHRoYXQgaXMgY3VycmVudGx5IGJlaW5nIG1vdmVkLlxuICAgKi9cbiAgdGh1bWJBY3RpdmVDbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCB0cmFja3MgYmV0d2VlbiB0aGUgdGh1bWJzIHdpbGwgYmUgcmVuZGVyZWQuXG4gICAqL1xuICB3aXRoVHJhY2tzOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogVGhlIGNzcyBjbGFzcyBzZXQgb24gdGhlIHRyYWNrcyBiZXR3ZWVuIHRoZSB0aHVtYnMuXG4gICAqIEluIGFkZGl0aW9uIHRyYWNrIGZyYWdtZW50IHdpbGwgcmVjZWl2ZSBhIG51bWJlcmVkIGNzcyBjbGFzcyBvZiB0aGUgZm9ybVxuICAgKiBgJHt0cmFja0NsYXNzTmFtZX0tJHtpfWAsIGUuZy4gYHRyYWNrLTBgLCBgdHJhY2stMWAsIC4uLlxuICAgKi9cbiAgdHJhY2tDbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCB0aGUgYWN0aXZlIHRodW1iIHdpbGwgcHVzaCBvdGhlciB0aHVtYnNcbiAgICogd2l0aGluIHRoZSBjb25zdHJhaW50cyBvZiBgbWluYCwgYG1heGAsIGBzdGVwYCBhbmQgYG1pbkRpc3RhbmNlYC5cbiAgICovXG4gIHBlYXJsaW5nOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogSWYgYHRydWVgIHRoZSB0aHVtYnMgY2FuJ3QgYmUgbW92ZWQuXG4gICAqL1xuICBkaXNhYmxlZDogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIERpc2FibGVzIHRodW1iIG1vdmUgd2hlbiBjbGlja2luZyB0aGUgc2xpZGVyIHRyYWNrXG4gICAqL1xuICBzbmFwRHJhZ0Rpc2FibGVkOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogSW52ZXJ0cyB0aGUgc2xpZGVyLlxuICAgKi9cbiAgaW52ZXJ0OiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogU2hvd3MgcGFzc2VkIG1hcmtzIG9uIHRoZSB0cmFjaywgaWYgdHJ1ZSBpdCBzaG93cyBhbGwgdGhlIG1hcmtzLFxuICAgKiBpZiBhbiBhcnJheSBvZiBudW1iZXJzIGl0IHNob3dzIGp1c3QgdGhlIHBhc3NlZCBtYXJrcywgaWYgYSBudW1iZXIgaXMgcGFzc2VkXG4gICAqIGl0IHNob3dzIGp1c3QgdGhlIG1hcmtzIGluIHRoYXQgc3RlcHM6IGxpa2UgcGFzc2luZyAzIHNob3dzIHRoZSBtYXJrcyAzLCA2LCA5XG4gICAqL1xuICBtYXJrczogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLm51bWJlciksIFByb3BUeXBlcy5ib29sLCBQcm9wVHlwZXMubnVtYmVyXSksXG5cbiAgLyoqXG4gICAqIFRoZSBjc3MgY2xhc3Mgc2V0IG9uIHRoZSBtYXJrcy5cbiAgICovXG4gIG1hcmtDbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGNhbGxlZCBiZWZvcmUgc3RhcnRpbmcgdG8gbW92ZSBhIHRodW1iLiBUaGUgY2FsbGJhY2sgd2lsbCBvbmx5IGJlIGNhbGxlZCBpZiB0aGVcbiAgICogYWN0aW9uIHdpbGwgcmVzdWx0IGluIGEgY2hhbmdlLiBUaGUgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgd2l0aCB0d28gYXJndW1lbnRzLCB0aGUgZmlyc3RcbiAgICogYmVpbmcgdGhlIGluaXRpYWwgdmFsdWUocykgdGhlIHNlY29uZCBiZWluZyB0aHVtYiBpbmRleC5cbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGVuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB6aWxsb3cvcmVhY3QvcmVxdWlyZS1kZWZhdWx0LXByb3BzLCB6aWxsb3cvcmVhY3Qvbm8tdW51c2VkLXByb3AtdHlwZXNcbiAgb25CZWZvcmVDaGFuZ2U6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBjYWxsZWQgb24gZXZlcnkgdmFsdWUgY2hhbmdlLlxuICAgKiBUaGUgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgd2l0aCB0d28gYXJndW1lbnRzLCB0aGUgZmlyc3QgYmVpbmcgdGhlIG5ldyB2YWx1ZShzKVxuICAgKiB0aGUgc2Vjb25kIGJlaW5nIHRodW1iIGluZGV4LlxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1sZW5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHppbGxvdy9yZWFjdC9yZXF1aXJlLWRlZmF1bHQtcHJvcHMsIHppbGxvdy9yZWFjdC9uby11bnVzZWQtcHJvcC10eXBlc1xuICBvbkNoYW5nZTogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGNhbGxlZCBvbmx5IGFmdGVyIG1vdmluZyBhIHRodW1iIGhhcyBlbmRlZC4gVGhlIGNhbGxiYWNrIHdpbGwgb25seSBiZSBjYWxsZWQgaWZcbiAgICogdGhlIGFjdGlvbiByZXN1bHRlZCBpbiBhIGNoYW5nZS4gVGhlIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHdpdGggdHdvIGFyZ3VtZW50cywgdGhlXG4gICAqIGZpcnN0IGJlaW5nIHRoZSByZXN1bHQgdmFsdWUocykgdGhlIHNlY29uZCBiZWluZyB0aHVtYiBpbmRleC5cbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGVuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB6aWxsb3cvcmVhY3QvcmVxdWlyZS1kZWZhdWx0LXByb3BzLCB6aWxsb3cvcmVhY3Qvbm8tdW51c2VkLXByb3AtdHlwZXNcbiAgb25BZnRlckNoYW5nZTogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGNhbGxlZCB3aGVuIHRoZSB0aGUgc2xpZGVyIGlzIGNsaWNrZWQgKHRodW1iIG9yIHRyYWNrcykuXG4gICAqIFJlY2VpdmVzIHRoZSB2YWx1ZSBhdCB0aGUgY2xpY2tlZCBwb3NpdGlvbiBhcyBhcmd1bWVudC5cbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB6aWxsb3cvcmVhY3QvcmVxdWlyZS1kZWZhdWx0LXByb3BzXG4gIG9uU2xpZGVyQ2xpY2s6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBhcmlhLWxhYmVsIGZvciBzY3JlZW4tcmVhZGVycyB0byBhcHBseSB0byB0aGUgdGh1bWJzLlxuICAgKiBVc2UgYW4gYXJyYXkgZm9yIG1vcmUgdGhhbiBvbmUgdGh1bWIuXG4gICAqIFRoZSBsZW5ndGggb2YgdGhlIGFycmF5IG11c3QgbWF0Y2ggdGhlIG51bWJlciBvZiB0aHVtYnMgaW4gdGhlIHZhbHVlIGFycmF5LlxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHppbGxvdy9yZWFjdC9yZXF1aXJlLWRlZmF1bHQtcHJvcHNcbiAgYXJpYUxhYmVsOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMuc3RyaW5nKV0pLFxuXG4gIC8qKlxuICAgKiBhcmlhLWxhYmVsbGVkYnkgZm9yIHNjcmVlbi1yZWFkZXJzIHRvIGFwcGx5IHRvIHRoZSB0aHVtYnMuXG4gICAqIFVzZWQgd2hlbiBzbGlkZXIgcmVuZGVyZWQgd2l0aCBzZXBhcmF0ZSBsYWJlbC5cbiAgICogVXNlIGFuIGFycmF5IGZvciBtb3JlIHRoYW4gb25lIHRodW1iLlxuICAgKiBUaGUgbGVuZ3RoIG9mIHRoZSBhcnJheSBtdXN0IG1hdGNoIHRoZSBudW1iZXIgb2YgdGh1bWJzIGluIHRoZSB2YWx1ZSBhcnJheS5cbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB6aWxsb3cvcmVhY3QvcmVxdWlyZS1kZWZhdWx0LXByb3BzXG4gIGFyaWFMYWJlbGxlZGJ5OiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMuc3RyaW5nKV0pLFxuXG4gIC8qKlxuICAgKiBhcmlhLXZhbHVldGV4dCBmb3Igc2NyZWVuLXJlYWRlcnMuXG4gICAqIENhbiBiZSBhIHN0YXRpYyBzdHJpbmcsIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgc3RyaW5nLlxuICAgKiBUaGUgZnVuY3Rpb24gd2lsbCBiZSBwYXNzZWQgYSBzaW5nbGUgYXJndW1lbnQsXG4gICAqIGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICpcbiAgICogICAgIHN0YXRlID0+IGBWYWx1ZTogJHtzdGF0ZS52YWx1ZX1gXG4gICAqXG4gICAqIC0gYHN0YXRlLmluZGV4YCB7YG51bWJlcmB9IHRoZSBpbmRleCBvZiB0aGUgdGh1bWJcbiAgICogLSBgc3RhdGUudmFsdWVgIHtgbnVtYmVyYCB8IGBhcnJheWB9IHRoZSBjdXJyZW50IHZhbHVlIHN0YXRlXG4gICAqIC0gYHN0YXRlLnZhbHVlTm93YCB7YG51bWJlcmB9IHRoZSB2YWx1ZSBvZiB0aGUgdGh1bWIgKGkuZS4gYXJpYS12YWx1ZW5vdylcbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB6aWxsb3cvcmVhY3QvcmVxdWlyZS1kZWZhdWx0LXByb3BzXG4gIGFyaWFWYWx1ZXRleHQ6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5mdW5jXSksXG5cbiAgLyoqXG4gICAqIFByb3ZpZGUgYSBjdXN0b20gcmVuZGVyIGZ1bmN0aW9uIGZvciB0aGUgdHJhY2sgbm9kZS5cbiAgICogVGhlIHJlbmRlciBmdW5jdGlvbiB3aWxsIGJlIHBhc3NlZCB0d28gYXJndW1lbnRzLFxuICAgKiBhbiBvYmplY3Qgd2l0aCBwcm9wcyB0aGF0IHNob3VsZCBiZSBhZGRlZCB0byB5b3VyIGhhbmRsZSBub2RlLFxuICAgKiBhbmQgYW4gb2JqZWN0IHdpdGggdHJhY2sgYW5kIHNsaWRlciBzdGF0ZTpcbiAgICpcbiAgICogICAgIChwcm9wcywgc3RhdGUpID0+IDxkaXYgey4uLnByb3BzfSAvPlxuICAgKlxuICAgKiAtIGBwcm9wc2Age2BvYmplY3RgfSBwcm9wcyB0byBiZSBzcHJlYWQgaW50byB5b3VyIHRyYWNrIG5vZGVcbiAgICogLSBgc3RhdGUuaW5kZXhgIHtgbnVtYmVyYH0gdGhlIGluZGV4IG9mIHRoZSB0cmFja1xuICAgKiAtIGBzdGF0ZS52YWx1ZWAge2BudW1iZXJgIHwgYGFycmF5YH0gdGhlIGN1cnJlbnQgdmFsdWUgc3RhdGVcbiAgICovXG4gIHJlbmRlclRyYWNrOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogUHJvdmlkZSBhIGN1c3RvbSByZW5kZXIgZnVuY3Rpb24gZm9yIGR5bmFtaWMgdGh1bWIgY29udGVudC5cbiAgICogVGhlIHJlbmRlciBmdW5jdGlvbiB3aWxsIGJlIHBhc3NlZCB0d28gYXJndW1lbnRzLFxuICAgKiBhbiBvYmplY3Qgd2l0aCBwcm9wcyB0aGF0IHNob3VsZCBiZSBhZGRlZCB0byB5b3VyIHRodW1iIG5vZGUsXG4gICAqIGFuZCBhbiBvYmplY3Qgd2l0aCB0aHVtYiBhbmQgc2xpZGVyIHN0YXRlOlxuICAgKlxuICAgKiAgICAgKHByb3BzLCBzdGF0ZSkgPT4gPGRpdiB7Li4ucHJvcHN9IC8+XG4gICAqXG4gICAqIC0gYHByb3BzYCB7YG9iamVjdGB9IHByb3BzIHRvIGJlIHNwcmVhZCBpbnRvIHlvdXIgdGh1bWIgbm9kZVxuICAgKiAtIGBzdGF0ZS5pbmRleGAge2BudW1iZXJgfSB0aGUgaW5kZXggb2YgdGhlIHRodW1iXG4gICAqIC0gYHN0YXRlLnZhbHVlYCB7YG51bWJlcmAgfCBgYXJyYXlgfSB0aGUgY3VycmVudCB2YWx1ZSBzdGF0ZVxuICAgKiAtIGBzdGF0ZS52YWx1ZU5vd2Age2BudW1iZXJgfSB0aGUgdmFsdWUgb2YgdGhlIHRodW1iIChpLmUuIGFyaWEtdmFsdWVub3cpXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgemlsbG93L3JlYWN0L3JlcXVpcmUtZGVmYXVsdC1wcm9wc1xuICByZW5kZXJUaHVtYjogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIFByb3ZpZGUgYSBjdXN0b20gcmVuZGVyIGZ1bmN0aW9uIGZvciB0aGUgbWFyayBub2RlLlxuICAgKiBUaGUgcmVuZGVyIGZ1bmN0aW9uIHdpbGwgYmUgcGFzc2VkIG9uZSBhcmd1bWVudCxcbiAgICogYW4gb2JqZWN0IHdpdGggcHJvcHMgdGhhdCBzaG91bGQgYmUgYWRkZWQgdG8geW91ciBoYW5kbGUgbm9kZVxuICAgKlxuICAgKiAgICAgKHByb3BzKSA9PiA8c3BhbiB7Li4ucHJvcHN9IC8+XG4gICAqXG4gICAqIC0gYHByb3BzYCB7YG9iamVjdGB9IHByb3BzIHRvIGJlIHNwcmVhZCBpbnRvIHlvdXIgdHJhY2sgbm9kZVxuICAgKi9cbiAgcmVuZGVyTWFyazogUHJvcFR5cGVzLmZ1bmNcbn0gOiB7fTtcbnZhciBSZWFjdFNsaWRlciQxID0gUmVhY3RTbGlkZXI7XG5cbmV4cG9ydCB7IFJlYWN0U2xpZGVyJDEgYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmVhY3RTbGlkZXIubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9